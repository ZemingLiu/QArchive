
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>qarchivecompressor_p.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &lt;QCoreApplication&gt;</a>
<a name="ln2">#include &lt;QDateTime&gt;</a>
<a name="ln3">#include &lt;QFileInfo&gt;</a>
<a name="ln4">#include &lt;QVector&gt;</a>
<a name="ln5">#include &lt;QDir&gt;</a>
<a name="ln6">#include &lt;QDebug&gt;</a>
<a name="ln7">#include &lt;QElapsedTimer&gt;</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;qarchive_enums.hpp&quot;</a>
<a name="ln11">#include &quot;qarchivecompressor_p.hpp&quot;</a>
<a name="ln12"> </a>
<a name="ln13">extern &quot;C&quot; {</a>
<a name="ln14">#include &lt;archive.h&gt;</a>
<a name="ln15">#include &lt;archive_entry.h&gt;</a>
<a name="ln16">#include &lt;fcntl.h&gt;</a>
<a name="ln17">#include &lt;stdio.h&gt;</a>
<a name="ln18">#include &lt;stdlib.h&gt;</a>
<a name="ln19">#include &lt;string.h&gt;</a>
<a name="ln20">#include &lt;sys/types.h&gt;</a>
<a name="ln21">#include &lt;sys/stat.h&gt;</a>
<a name="ln22">}</a>
<a name="ln23"> </a>
<a name="ln24">using namespace QArchive;</a>
<a name="ln25"> </a>
<a name="ln26">// Node is a private structure which is used store info about entries to be</a>
<a name="ln27">// compressed by the Compressor.</a>
<a name="ln28">CompressorPrivate::Node::Node() { }</a>
<a name="ln29">CompressorPrivate::Node::~Node() {</a>
<a name="ln30">    if(!valid) {</a>
<a name="ln31">        return;</a>
<a name="ln32">    }</a>
<a name="ln33">}</a>
<a name="ln34"> </a>
<a name="ln35">short CompressorPrivate::Node::open() {</a>
<a name="ln36">    if(valid) {</a>
<a name="ln37">        return NoError;</a>
<a name="ln38">    }</a>
<a name="ln39"> </a>
<a name="ln40">    if(path.isEmpty() &amp;&amp; (io == nullptr &amp;&amp; entry.isEmpty())) {</a>
<a name="ln41">        return FileDoesNotExist;</a>
<a name="ln42">    }</a>
<a name="ln43"> </a>
<a name="ln44">    if(path.isEmpty() &amp;&amp; io) {</a>
<a name="ln45">        isInMemory = true;</a>
<a name="ln46">        if(!io-&gt;isOpen() &amp;&amp;</a>
<a name="ln47">                !io-&gt;open(QIODevice::ReadOnly)) {</a>
<a name="ln48">            return CannotOpenFile;</a>
<a name="ln49">        }</a>
<a name="ln50"> </a>
<a name="ln51">        if(!io-&gt;isReadable()) {</a>
<a name="ln52">            return NoPermissionToReadFile;</a>
<a name="ln53">        }</a>
<a name="ln54"> </a>
<a name="ln55">        if(io-&gt;isSequential()) {</a>
<a name="ln56">            return IODeviceSequential;</a>
<a name="ln57">        }</a>
<a name="ln58"> </a>
<a name="ln59">    }</a>
<a name="ln60"> </a>
<a name="ln61">    valid = true;</a>
<a name="ln62">    return NoError;</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65">void CompressorPrivate::freeNodes(QVector&lt;Node*&gt; *vec) {</a>
<a name="ln66">    for(auto iter = vec-&gt;begin(),</a>
<a name="ln67">            end = vec-&gt;end();</a>
<a name="ln68">            iter != end;</a>
<a name="ln69">            ++iter) {</a>
<a name="ln70">        if(*iter) {</a>
<a name="ln71">		delete *iter;</a>
<a name="ln72">	}</a>
<a name="ln73">    }</a>
<a name="ln74">    vec-&gt;clear();</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">static bool contains(const QString &amp;entry, QVector&lt;CompressorPrivate::Node*&gt; *vec) {</a>
<a name="ln78">for(auto iter = vec-&gt;begin(),</a>
<a name="ln79">            end = vec-&gt;end();</a>
<a name="ln80">            iter != end;</a>
<a name="ln81">            ++iter) {</a>
<a name="ln82">        if(*iter &amp;&amp; (*iter)-&gt;valid) {</a>
<a name="ln83">		if((*iter)-&gt;entry == entry) {</a>
<a name="ln84">			return true;</a>
<a name="ln85">		}</a>
<a name="ln86">	}</a>
<a name="ln87">}</a>
<a name="ln88">return false;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">// CompressorPrivate is the private class which handles the</a>
<a name="ln92">// compression of data to disk.</a>
<a name="ln93">// It can compress data in all formats of archive supported by libarchive.</a>
<a name="ln94">// However there is a method to set password for archives , Only</a>
<a name="ln95">// ZIP Format is currently supported for encrypting archives with a user given.</a>
<a name="ln96">CompressorPrivate::CompressorPrivate(bool memoryMode)</a>
<a name="ln97">    : QObject() {</a>
<a name="ln98">    b_MemoryMode = memoryMode;</a>
<a name="ln99"> </a>
<a name="ln100">    if(!b_MemoryMode) {</a>
<a name="ln101">        m_TemporaryFile.reset(new QSaveFile);</a>
<a name="ln102">    } else {</a>
<a name="ln103">        m_Buffer.reset(new QBuffer);</a>
<a name="ln104">    }</a>
<a name="ln105">    m_StaggedFiles.reset(new QVector&lt;Node*&gt;);</a>
<a name="ln106">    m_ConfirmedFiles.reset(new QVector&lt;Node*&gt;);</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">CompressorPrivate::~CompressorPrivate() {</a>
<a name="ln110">   clear();</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">// Set the filename for the archive to written on disk , the filename can</a>
<a name="ln114">// be relative or absolute as long it is not existing already or does</a>
<a name="ln115">// not have the permission to write.</a>
<a name="ln116">void CompressorPrivate::setFileName(const QString &amp;fileName) {</a>
<a name="ln117">    if(b_MemoryMode || b_Started || b_Paused) {</a>
<a name="ln118">        return;</a>
<a name="ln119">    }</a>
<a name="ln120">    m_TemporaryFile-&gt;setFileName(fileName);</a>
<a name="ln121">    return;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">// Explicitly set the format of the archive , when the format is explicitly set</a>
<a name="ln125">// then even if the filename corresponds to some other format , the compressor will</a>
<a name="ln126">// only compress the data in the given archive format.</a>
<a name="ln127">void CompressorPrivate::setArchiveFormat(short format) {</a>
<a name="ln128">    if(b_Started || b_Paused) {</a>
<a name="ln129">        return;</a>
<a name="ln130">    }</a>
<a name="ln131">    m_ArchiveFormat = format;</a>
<a name="ln132">    return;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">// Only used for ZIP Archives , other formats are ignored.</a>
<a name="ln136">void CompressorPrivate::setPassword(const QString &amp;passwd) {</a>
<a name="ln137">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln138">    if(b_Started || b_Paused) {</a>
<a name="ln139">        return;</a>
<a name="ln140">    }</a>
<a name="ln141">    m_Password = passwd;</a>
<a name="ln142">#else</a>
<a name="ln143">    (void)passwd;</a>
<a name="ln144">#endif</a>
<a name="ln145">    return;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">void CompressorPrivate::setBlockSize(int size) {</a>
<a name="ln149">    if(b_Started || b_Paused) {</a>
<a name="ln150">        return;</a>
<a name="ln151">    }</a>
<a name="ln152">    n_BlockSize = size;</a>
<a name="ln153">    return;</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">void CompressorPrivate::addFiles(const QString &amp;entryName, QIODevice *device) {</a>
<a name="ln157">    if(b_Started || b_Paused) {</a>
<a name="ln158">        return;</a>
<a name="ln159">    }</a>
<a name="ln160"> </a>
<a name="ln161">    auto node = new Node;</a>
<a name="ln162">    node-&gt;entry = entryName;</a>
<a name="ln163">    node-&gt;io = device;</a>
<a name="ln164">    m_StaggedFiles-&gt;append(node);</a>
<a name="ln165">    return;</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168">void CompressorPrivate::addFiles(const QStringList &amp;entries, const QVariantList &amp;devices) {</a>
<a name="ln169">    if(b_Started || b_Paused) {</a>
<a name="ln170">        return;</a>
<a name="ln171">    }</a>
<a name="ln172"> </a>
<a name="ln173">    if(entries.size() != devices.size()) {</a>
<a name="ln174">        return;</a>
<a name="ln175">    }</a>
<a name="ln176"> </a>
<a name="ln177">    for(auto i = 0; i &lt; entries.size(); ++i) {</a>
<a name="ln178">        auto node = new Node;</a>
<a name="ln179">        node-&gt;entry = entries.at(i);</a>
<a name="ln180">        node-&gt;io = devices.at(i).value&lt;QIODevice*&gt;();</a>
<a name="ln181">        m_StaggedFiles-&gt;append(node);</a>
<a name="ln182">    }</a>
<a name="ln183">    return;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">void CompressorPrivate::addFiles(const QString &amp;file) {</a>
<a name="ln187">    if(b_Started || b_Paused) {</a>
<a name="ln188">        return;</a>
<a name="ln189">    }</a>
<a name="ln190"> </a>
<a name="ln191">    QFileInfo info(file);</a>
<a name="ln192">    if(contains(info.fileName(), m_StaggedFiles.data())) {</a>
<a name="ln193">	    return;</a>
<a name="ln194">    }</a>
<a name="ln195"> </a>
<a name="ln196">    auto node = new Node;</a>
<a name="ln197">    node-&gt;path = file;</a>
<a name="ln198">    node-&gt;entry = info.fileName();</a>
<a name="ln199">    m_StaggedFiles-&gt;append(node);</a>
<a name="ln200">    return;</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">void CompressorPrivate::addFiles(const QStringList &amp;files) {</a>
<a name="ln204">    if(b_Started || b_Paused) {</a>
<a name="ln205">        return;</a>
<a name="ln206">    }</a>
<a name="ln207">    for(auto i = 0; i &lt; files.size(); ++i) {</a>
<a name="ln208">        QFileInfo info(files.at(i));</a>
<a name="ln209">        if(contains(info.fileName(), m_StaggedFiles.data())) {</a>
<a name="ln210">		continue;</a>
<a name="ln211">	}</a>
<a name="ln212"> </a>
<a name="ln213">	auto node = new Node;</a>
<a name="ln214">        node-&gt;path = files.at(i);</a>
<a name="ln215">        node-&gt;entry = info.fileName();</a>
<a name="ln216">        m_StaggedFiles-&gt;append(node);</a>
<a name="ln217">    }</a>
<a name="ln218">    return;</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221">// Adds a single file and uses a custom entry name with</a>
<a name="ln222">// respect to the given data.</a>
<a name="ln223">void CompressorPrivate::addFiles(const QString &amp;entryName, const QString &amp;file) {</a>
<a name="ln224">    if(b_Started || b_Paused) {</a>
<a name="ln225">        return;</a>
<a name="ln226">    }</a>
<a name="ln227">    if(contains(entryName, m_StaggedFiles.data())) {</a>
<a name="ln228">	return;</a>
<a name="ln229">    }</a>
<a name="ln230"> </a>
<a name="ln231">    auto node = new Node;</a>
<a name="ln232">    node-&gt;path = file;</a>
<a name="ln233">    node-&gt;entry = entryName;</a>
<a name="ln234">    m_StaggedFiles-&gt;append(node);</a>
<a name="ln235">    return;</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">// Adds multiple files and uses a corresponding list of</a>
<a name="ln239">// entry names with respect to the given data.</a>
<a name="ln240">void CompressorPrivate::addFiles(const QStringList &amp;entryNames, const QStringList &amp;files) {</a>
<a name="ln241">    if(b_Started || b_Paused) {</a>
<a name="ln242">        return;</a>
<a name="ln243">    }</a>
<a name="ln244">    if(entryNames.size() != files.size()) {</a>
<a name="ln245">        return;</a>
<a name="ln246">    }</a>
<a name="ln247">    for(auto i = 0; i &lt; files.size(); ++i) {</a>
<a name="ln248">        if(contains(entryNames.at(i), m_StaggedFiles.data())) {</a>
<a name="ln249">		continue;</a>
<a name="ln250">	}</a>
<a name="ln251"> </a>
<a name="ln252">	auto node = new Node;</a>
<a name="ln253">        node-&gt;path = files.at(i);</a>
<a name="ln254">        node-&gt;entry = entryNames.at(i);</a>
<a name="ln255">        m_StaggedFiles-&gt;append(node);</a>
<a name="ln256">    }</a>
<a name="ln257">    return;</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260">void CompressorPrivate::removeFiles(const QString &amp;entry) {</a>
<a name="ln261">    if(b_Started || b_Paused) {</a>
<a name="ln262">        return;</a>
<a name="ln263">    }</a>
<a name="ln264">    int index = 0;</a>
<a name="ln265">    for(auto iter = m_StaggedFiles-&gt;begin(),</a>
<a name="ln266">            end = m_StaggedFiles-&gt;end();</a>
<a name="ln267">            iter != end;</a>
<a name="ln268">            ++iter) {</a>
<a name="ln269">        if(*iter &amp;&amp; (*iter)-&gt;entry == entry) {</a>
<a name="ln270">            m_StaggedFiles-&gt;remove(index);</a>
<a name="ln271">            return;</a>
<a name="ln272">        }</a>
<a name="ln273">        ++index;</a>
<a name="ln274">    }</a>
<a name="ln275">    return;</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">void CompressorPrivate::removeFiles(const QStringList &amp;entries) {</a>
<a name="ln279">    if(b_Started || b_Paused) {</a>
<a name="ln280">        return;</a>
<a name="ln281">    }</a>
<a name="ln282">    QVector&lt;int&gt; indexes;</a>
<a name="ln283">    int index = 0;</a>
<a name="ln284">    for(auto iter = m_StaggedFiles-&gt;begin(),</a>
<a name="ln285">            end = m_StaggedFiles-&gt;end();</a>
<a name="ln286">            iter != end;</a>
<a name="ln287">            ++iter) {</a>
<a name="ln288">        if(*iter &amp;&amp; entries.contains((*iter)-&gt;entry)) {</a>
<a name="ln289">            indexes.append(index);</a>
<a name="ln290">            return;</a>
<a name="ln291">        }</a>
<a name="ln292">        ++index;</a>
<a name="ln293">    }</a>
<a name="ln294"> </a>
<a name="ln295">    for(auto iter = indexes.begin(),</a>
<a name="ln296">            end = indexes.end();</a>
<a name="ln297">            iter != end;</a>
<a name="ln298">            ++iter) {</a>
<a name="ln299">        m_StaggedFiles-&gt;remove(*iter);</a>
<a name="ln300">    }</a>
<a name="ln301">    return;</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">Q_DECL_DEPRECATED void CompressorPrivate::removeFiles(const QString &amp;entryName, const QString &amp;file) {</a>
<a name="ln305">    if(b_Started || b_Paused) {</a>
<a name="ln306">        return;</a>
<a name="ln307">    }</a>
<a name="ln308">    Q_UNUSED(file);</a>
<a name="ln309">    int index = 0;</a>
<a name="ln310">    for(auto iter = m_StaggedFiles-&gt;begin(),</a>
<a name="ln311">            end = m_StaggedFiles-&gt;end();</a>
<a name="ln312">            iter != end;</a>
<a name="ln313">            ++iter) {</a>
<a name="ln314">        if(*iter &amp;&amp; (*iter)-&gt;entry == entryName) {</a>
<a name="ln315">            m_StaggedFiles-&gt;remove(index);</a>
<a name="ln316">            return;</a>
<a name="ln317">        }</a>
<a name="ln318">        ++index;</a>
<a name="ln319">    }</a>
<a name="ln320">    return;</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">Q_DECL_DEPRECATED void CompressorPrivate::removeFiles(const QStringList &amp;entryNames, const QStringList &amp;files) {</a>
<a name="ln324">    if(b_Started || b_Paused) {</a>
<a name="ln325">        return;</a>
<a name="ln326">    }</a>
<a name="ln327">    Q_UNUSED(files);</a>
<a name="ln328">    QVector&lt;int&gt; indexes;</a>
<a name="ln329">    int index = 0;</a>
<a name="ln330">    for(auto iter = m_StaggedFiles-&gt;begin(),</a>
<a name="ln331">            end = m_StaggedFiles-&gt;end();</a>
<a name="ln332">            iter != end;</a>
<a name="ln333">            ++iter) {</a>
<a name="ln334">        if(*iter &amp;&amp; entryNames.contains((*iter)-&gt;entry)) {</a>
<a name="ln335">            indexes.append(index);</a>
<a name="ln336">            return;</a>
<a name="ln337">        }</a>
<a name="ln338">        ++index;</a>
<a name="ln339">    }</a>
<a name="ln340"> </a>
<a name="ln341">    for(auto iter = indexes.begin(),</a>
<a name="ln342">            end = indexes.end();</a>
<a name="ln343">            iter != end;</a>
<a name="ln344">            ++iter) {</a>
<a name="ln345">        m_StaggedFiles-&gt;remove(*iter);</a>
<a name="ln346">    }</a>
<a name="ln347"> </a>
<a name="ln348">    return;</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">/* clears internal cache. */</a>
<a name="ln352">void CompressorPrivate::clear() {</a>
<a name="ln353">    if(b_Started) {</a>
<a name="ln354">        return;</a>
<a name="ln355">    }</a>
<a name="ln356">    b_PauseRequested = b_CancelRequested = b_Paused = b_Started = b_Finished = false;</a>
<a name="ln357">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln358">    m_Password.clear();</a>
<a name="ln359">#endif</a>
<a name="ln360"> </a>
<a name="ln361">    m_ArchiveFormat = 0;</a>
<a name="ln362">    n_BlockSize = 10240;</a>
<a name="ln363"> </a>
<a name="ln364">    // TODO: do we need to reset n_BytesTotal here?</a>
<a name="ln365">    n_BytesProcessed = 0;</a>
<a name="ln366">    n_BytesTotal = 0;</a>
<a name="ln367"> </a>
<a name="ln368">    freeNodes(m_ConfirmedFiles.data());</a>
<a name="ln369">    freeNodes(m_StaggedFiles.data());</a>
<a name="ln370"> </a>
<a name="ln371">    if(!b_MemoryMode) {</a>
<a name="ln372">        m_TemporaryFile.reset(new QSaveFile);</a>
<a name="ln373">    } else {</a>
<a name="ln374">        m_Buffer.reset(new QBuffer);</a>
<a name="ln375">    }</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">// Starts the compression.</a>
<a name="ln379">void CompressorPrivate::start() {</a>
<a name="ln380">    if(b_Started || b_Paused) {</a>
<a name="ln381">        return;</a>
<a name="ln382">    } else if(!b_MemoryMode &amp;&amp; m_TemporaryFile-&gt;fileName().isEmpty()) {</a>
<a name="ln383">        emit error(ArchiveFileNameNotGiven, QString());</a>
<a name="ln384">        return;</a>
<a name="ln385">    } else if(!b_MemoryMode &amp;&amp; QFileInfo::exists(m_TemporaryFile-&gt;fileName())) {</a>
<a name="ln386">        emit error(ArchiveFileAlreadyExists, m_TemporaryFile-&gt;fileName());</a>
<a name="ln387">        return;</a>
<a name="ln388">    } else if(m_StaggedFiles-&gt;isEmpty()) {</a>
<a name="ln389">        if(b_MemoryMode) {</a>
<a name="ln390">            emit error(NoFilesToCompress, QString());</a>
<a name="ln391">        } else {</a>
<a name="ln392">            emit error(NoFilesToCompress, m_TemporaryFile-&gt;fileName());</a>
<a name="ln393">        }</a>
<a name="ln394">        return;</a>
<a name="ln395">    }</a>
<a name="ln396"> </a>
<a name="ln397">    // Guess Archive Format if not given.</a>
<a name="ln398">    if(!m_ArchiveFormat) { // if ArchiveFormat == 0 then no format is set.</a>
<a name="ln399">        if(!guessArchiveFormat()) {</a>
<a name="ln400">            m_ArchiveFormat = ZipFormat; // Default format.</a>
<a name="ln401">        }</a>
<a name="ln402">    }</a>
<a name="ln403"> </a>
<a name="ln404">    /// Confirm files.</a>
<a name="ln405">    n_BytesTotal = 0;</a>
<a name="ln406">    if(!confirmFiles()) {</a>
<a name="ln407">        return;</a>
<a name="ln408">    }</a>
<a name="ln409"> </a>
<a name="ln410">    b_Started = true;</a>
<a name="ln411">    b_Finished = false;</a>
<a name="ln412">    emit started();</a>
<a name="ln413"> </a>
<a name="ln414">    n_BytesProcessed = 0;</a>
<a name="ln415"> </a>
<a name="ln416">    short ret = compress();</a>
<a name="ln417">    if(ret == NoError) {</a>
<a name="ln418">        b_Started = false;</a>
<a name="ln419">        b_Finished = true;</a>
<a name="ln420">        if(b_MemoryMode) {</a>
<a name="ln421">            emit memoryFinished(m_Buffer.take());</a>
<a name="ln422">            m_Buffer.reset(new QBuffer);</a>
<a name="ln423">        } else {</a>
<a name="ln424">            m_TemporaryFile-&gt;commit();</a>
<a name="ln425">            emit diskFinished();</a>
<a name="ln426">        }</a>
<a name="ln427">    } else if(ret == OperationCanceled) {</a>
<a name="ln428">        b_Started = false;</a>
<a name="ln429">        emit canceled();</a>
<a name="ln430">    } else if(ret == OperationPaused) {</a>
<a name="ln431">        b_Started = false;</a>
<a name="ln432">        b_Paused = true;</a>
<a name="ln433">        emit paused();</a>
<a name="ln434">    }</a>
<a name="ln435">    return;</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">void CompressorPrivate::resume() {</a>
<a name="ln439">    if(!b_Paused || b_Finished) {</a>
<a name="ln440">        return;</a>
<a name="ln441">    }</a>
<a name="ln442">    b_Paused = false;</a>
<a name="ln443">    b_Started = true;</a>
<a name="ln444">    emit resumed();</a>
<a name="ln445"> </a>
<a name="ln446">    short ret = compress();</a>
<a name="ln447">    if(ret == NoError) {</a>
<a name="ln448">        b_Started = false;</a>
<a name="ln449">        b_Finished = true;</a>
<a name="ln450">        if(b_MemoryMode) {</a>
<a name="ln451">            emit memoryFinished(m_Buffer.take());</a>
<a name="ln452">            m_Buffer.reset(new QBuffer);</a>
<a name="ln453">        } else {</a>
<a name="ln454">            m_TemporaryFile-&gt;commit();</a>
<a name="ln455">            emit diskFinished();</a>
<a name="ln456">        }</a>
<a name="ln457">    } else if(ret == OperationCanceled) {</a>
<a name="ln458">        b_Started = false;</a>
<a name="ln459">        emit canceled();</a>
<a name="ln460">    } else if(ret == OperationPaused) {</a>
<a name="ln461">        b_Started = false;</a>
<a name="ln462">        b_Paused = true;</a>
<a name="ln463">        emit paused();</a>
<a name="ln464">    } else {</a>
<a name="ln465">        b_Started = false;</a>
<a name="ln466">    }</a>
<a name="ln467">    return;</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">void CompressorPrivate::pause() {</a>
<a name="ln471">    if(!b_Started || b_Finished || b_Paused) {</a>
<a name="ln472">        return;</a>
<a name="ln473">    }</a>
<a name="ln474">    b_PauseRequested = true;</a>
<a name="ln475">    return;</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">// Cancels the current compression process, if the compression process is</a>
<a name="ln479">// paused then the compression cannot be canceled.</a>
<a name="ln480">void CompressorPrivate::cancel() {</a>
<a name="ln481">    if(!b_Started || b_Finished || b_Paused) {</a>
<a name="ln482">        return;</a>
<a name="ln483">    }</a>
<a name="ln484">    b_CancelRequested = true;</a>
<a name="ln485">    return;</a>
<a name="ln486">}</a>
<a name="ln487"> </a>
<a name="ln488">// Guesses the archive format from the given archive filename , on success</a>
<a name="ln489">// this returns true or vice-versa.</a>
<a name="ln490">bool CompressorPrivate::guessArchiveFormat() {</a>
<a name="ln491">    if(b_MemoryMode) {</a>
<a name="ln492">        return false;</a>
<a name="ln493">    }</a>
<a name="ln494"> </a>
<a name="ln495">    if(m_TemporaryFile-&gt;fileName().isEmpty()) {</a>
<a name="ln496">        return false;</a>
<a name="ln497">    }</a>
<a name="ln498"> </a>
<a name="ln499">    auto ext = QFileInfo(m_TemporaryFile-&gt;fileName()).suffix().toLower();</a>
<a name="ln500">    if(ext == &quot;bz&quot;) {</a>
<a name="ln501">        m_ArchiveFormat = BZipFormat;</a>
<a name="ln502">    } else if(ext == &quot;bz2&quot;) {</a>
<a name="ln503">        m_ArchiveFormat = BZip2Format;</a>
<a name="ln504">    } else if(ext == &quot;gz&quot;) {</a>
<a name="ln505">        m_ArchiveFormat = GZipFormat;</a>
<a name="ln506">    } else if(ext == &quot;xz&quot;) {</a>
<a name="ln507">        m_ArchiveFormat = XzFormat;</a>
<a name="ln508">    } else if(ext == &quot;tar&quot;) {</a>
<a name="ln509">        m_ArchiveFormat = TarFormat;</a>
<a name="ln510">    } else if(ext == &quot;xar&quot;) {</a>
<a name="ln511">        m_ArchiveFormat = XarFormat;</a>
<a name="ln512">    } else if(ext == &quot;zip&quot;) {</a>
<a name="ln513">        m_ArchiveFormat = ZipFormat;</a>
<a name="ln514">    } else if(ext == &quot;7z&quot;) {</a>
<a name="ln515">        m_ArchiveFormat = SevenZipFormat;</a>
<a name="ln516">    } else {</a>
<a name="ln517">        m_ArchiveFormat = 0;</a>
<a name="ln518">        return false;</a>
<a name="ln519">    }</a>
<a name="ln520"> </a>
<a name="ln521">    return true;</a>
<a name="ln522">}</a>
<a name="ln523"> </a>
<a name="ln524">// Confirms all the files that are stagged for compression , Returns true</a>
<a name="ln525">// on success and vice-versa.</a>
<a name="ln526">// This populates m_ConfirmedFiles vector with all the files added ,</a>
<a name="ln527">// Directory's files will be recursively added.</a>
<a name="ln528">bool CompressorPrivate::confirmFiles() {</a>
<a name="ln529">    freeNodes(m_ConfirmedFiles.data());</a>
<a name="ln530">    for(auto iter = m_StaggedFiles-&gt;begin() ; iter != m_StaggedFiles-&gt;end() ; ++iter) {</a>
<a name="ln531">        auto node = *iter;</a>
<a name="ln532">        short eCode = NoError;</a>
<a name="ln533">        if((eCode = node-&gt;open()) != NoError) {</a>
<a name="ln534">            if(!node-&gt;isInMemory) {</a>
<a name="ln535">                emit error(eCode, node-&gt;path);</a>
<a name="ln536">            } else {</a>
<a name="ln537">                emit error(eCode, QString());</a>
<a name="ln538">            }</a>
<a name="ln539">            return false;</a>
<a name="ln540">        }</a>
<a name="ln541"> </a>
<a name="ln542">        if(!node-&gt;valid) {</a>
<a name="ln543">            continue;</a>
<a name="ln544">        }</a>
<a name="ln545"> </a>
<a name="ln546">        if(!node-&gt;isInMemory) {</a>
<a name="ln547">            QFileInfo info(/* file path given by the user = */node-&gt;path);</a>
<a name="ln548"> </a>
<a name="ln549">            // Check if the file exists.</a>
<a name="ln550">            if(!info.exists()) {</a>
<a name="ln551">                emit error(FileDoesNotExist, info.filePath());</a>
<a name="ln552">                return false;</a>
<a name="ln553">            }</a>
<a name="ln554"> </a>
<a name="ln555">            // Check permission to read.</a>
<a name="ln556">            if(!info.isReadable()) {</a>
<a name="ln557">                emit error(NoPermissionToReadFile, info.filePath());</a>
<a name="ln558">                return false;</a>
<a name="ln559">            }</a>
<a name="ln560"> </a>
<a name="ln561"> </a>
<a name="ln562">            // Check if it is file or a directory ,</a>
<a name="ln563">            // if directory then add files in directory</a>
<a name="ln564">            // recursively.</a>
<a name="ln565">            if(info.isDir()) {</a>
<a name="ln566">                QVector&lt;QString&gt; dirList;</a>
<a name="ln567">		QString toReplace = info.filePath();</a>
<a name="ln568">                dirList.append(info.filePath());</a>
<a name="ln569"> </a>
<a name="ln570">                while(!dirList.isEmpty()) {</a>
<a name="ln571">                    QDir dir(dirList.takeFirst());</a>
<a name="ln572">                    QFileInfoList list = dir.entryInfoList(QDir::AllEntries | QDir::NoDotAndDotDot | QDir::Hidden);</a>
<a name="ln573">                    for (int i = 0; i &lt; list.size(); i++) {</a>
<a name="ln574">                        if(list.at(i).isDir()) {</a>
<a name="ln575">                            dirList.append(list.at(i).filePath());</a>
<a name="ln576">                            continue;</a>
<a name="ln577">                        }</a>
<a name="ln578">                        QString file = list.at(i).filePath();</a>
<a name="ln579">			auto fileNode = new Node;</a>
<a name="ln580">                        fileNode-&gt;isInMemory = node-&gt;isInMemory;</a>
<a name="ln581">			fileNode-&gt;valid = node-&gt;valid;</a>
<a name="ln582">			fileNode-&gt;path = file;</a>
<a name="ln583">			</a>
<a name="ln584">			if(toReplace[toReplace.size() - 1] == '/' || </a>
<a name="ln585">			   toReplace[toReplace.size() - 1] == '\\') {</a>
<a name="ln586">				if((node-&gt;entry)[(node-&gt;entry).size() - 1] != '/' &amp;&amp;</a>
<a name="ln587">				   (node-&gt;entry)[(node-&gt;entry).size() - 1] != '\\') {</a>
<a name="ln588">					(node-&gt;entry).append('/');</a>
<a name="ln589">				}</a>
<a name="ln590">			}</a>
<a name="ln591">			fileNode-&gt;entry = file.replace(toReplace, node-&gt;entry);</a>
<a name="ln592"> </a>
<a name="ln593">                        m_ConfirmedFiles-&gt;append(fileNode);</a>
<a name="ln594"> </a>
<a name="ln595">                        n_BytesTotal += QFileInfo(list.at(i).filePath()).size();</a>
<a name="ln596">                    }</a>
<a name="ln597">                }</a>
<a name="ln598">            } else { // Add it to the confirmed list.</a>
<a name="ln599">		auto fileNode = new Node;</a>
<a name="ln600">		fileNode-&gt;isInMemory = node-&gt;isInMemory;</a>
<a name="ln601">		fileNode-&gt;valid = node-&gt;valid;</a>
<a name="ln602">		fileNode-&gt;path = info.filePath();</a>
<a name="ln603">		fileNode-&gt;entry = node-&gt;entry;</a>
<a name="ln604">                m_ConfirmedFiles-&gt;append(fileNode);</a>
<a name="ln605">                n_BytesTotal += info.size();</a>
<a name="ln606">            }</a>
<a name="ln607">        } else { // If QIODevice given</a>
<a name="ln608">            auto fileNode = new Node;</a>
<a name="ln609">	    fileNode-&gt;isInMemory = node-&gt;isInMemory;</a>
<a name="ln610">	    fileNode-&gt;valid = node-&gt;valid;</a>
<a name="ln611">	    fileNode-&gt;io = node-&gt;io;</a>
<a name="ln612">	    fileNode-&gt;entry = node-&gt;entry;</a>
<a name="ln613">	    m_ConfirmedFiles-&gt;append(fileNode);</a>
<a name="ln614">            n_BytesTotal += node-&gt;io-&gt;size();</a>
<a name="ln615">        }</a>
<a name="ln616">    }</a>
<a name="ln617"> </a>
<a name="ln618">    /// Important: Check if total bytes is not zero.</a>
<a name="ln619">    if(n_BytesTotal == 0) {</a>
<a name="ln620">	return false;</a>
<a name="ln621">    }</a>
<a name="ln622">    return true;</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">// Does the compression and also resumes it if called twice.</a>
<a name="ln626">short CompressorPrivate::compress() {</a>
<a name="ln627">    if(m_ArchiveWrite.isNull()) {</a>
<a name="ln628">        if(!b_MemoryMode) {</a>
<a name="ln629">            /// Open Temporary file for write.</a>
<a name="ln630">            if(!m_TemporaryFile-&gt;open(QIODevice::WriteOnly)) {</a>
<a name="ln631">                emit error(ArchiveWriteOpenError, m_TemporaryFile-&gt;fileName());</a>
<a name="ln632">                return ArchiveWriteOpenError;</a>
<a name="ln633">            }</a>
<a name="ln634">        }</a>
<a name="ln635"> </a>
<a name="ln636">        m_ArchiveWrite = QSharedPointer&lt;struct archive&gt;(</a>
<a name="ln637">                             archive_write_new(), ArchiveWriteDestructor);</a>
<a name="ln638">        if(m_ArchiveWrite.isNull()) {</a>
<a name="ln639">            if(b_MemoryMode) {</a>
<a name="ln640">                emit error(NotEnoughMemory, QString());</a>
<a name="ln641">            } else {</a>
<a name="ln642">                emit error(NotEnoughMemory, m_TemporaryFile-&gt;fileName());</a>
<a name="ln643">            }</a>
<a name="ln644">            return NotEnoughMemory;</a>
<a name="ln645">        }</a>
<a name="ln646"> </a>
<a name="ln647">        switch (m_ArchiveFormat) {</a>
<a name="ln648">        case BZipFormat:</a>
<a name="ln649">        case BZip2Format:</a>
<a name="ln650">            archive_write_add_filter_bzip2(m_ArchiveWrite.data());</a>
<a name="ln651">            archive_write_set_format_gnutar(m_ArchiveWrite.data());</a>
<a name="ln652">            break;</a>
<a name="ln653">        case GZipFormat:</a>
<a name="ln654">            archive_write_add_filter_gzip(m_ArchiveWrite.data());</a>
<a name="ln655">            archive_write_set_format_gnutar(m_ArchiveWrite.data());</a>
<a name="ln656">            break;</a>
<a name="ln657">        case XzFormat:</a>
<a name="ln658">            archive_write_add_filter_xz(m_ArchiveWrite.data());</a>
<a name="ln659">            archive_write_set_format_gnutar(m_ArchiveWrite.data());</a>
<a name="ln660">            break;</a>
<a name="ln661">        case TarFormat:</a>
<a name="ln662">            archive_write_add_filter_none(m_ArchiveWrite.data());</a>
<a name="ln663">            archive_write_set_format_gnutar(m_ArchiveWrite.data());</a>
<a name="ln664">            break;</a>
<a name="ln665">        case XarFormat:</a>
<a name="ln666">            archive_write_add_filter_none(m_ArchiveWrite.data());</a>
<a name="ln667">            archive_write_set_format_xar(m_ArchiveWrite.data());</a>
<a name="ln668">            break;</a>
<a name="ln669">        case SevenZipFormat:</a>
<a name="ln670">            archive_write_add_filter_none(m_ArchiveWrite.data());</a>
<a name="ln671">            archive_write_set_format_7zip(m_ArchiveWrite.data());</a>
<a name="ln672">            break;</a>
<a name="ln673">        case ZipFormat:</a>
<a name="ln674">        default:</a>
<a name="ln675">            archive_write_add_filter_none(m_ArchiveWrite.data());</a>
<a name="ln676">            archive_write_set_format_zip(m_ArchiveWrite.data());</a>
<a name="ln677">            break;</a>
<a name="ln678">        }</a>
<a name="ln679"> </a>
<a name="ln680">        // Set Password if the format is Zip and a password is given by the user.</a>
<a name="ln681">        //</a>
<a name="ln682">        // Note:</a>
<a name="ln683">        // Currently only Zip format is officially supported by libarchive for the</a>
<a name="ln684">        // ability to use passwords and thus until the user uses Zip format , the</a>
<a name="ln685">        // password even if given is ignored.</a>
<a name="ln686">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln687">        if(!m_Password.isEmpty() &amp;&amp; m_ArchiveFormat == ZipFormat) {</a>
<a name="ln688">            archive_write_set_passphrase(m_ArchiveWrite.data(), m_Password.toUtf8().constData());</a>
<a name="ln689">            archive_write_set_options(m_ArchiveWrite.data(), &quot;zip:encryption=traditional&quot;);</a>
<a name="ln690">        }</a>
<a name="ln691">#endif</a>
<a name="ln692"> </a>
<a name="ln693">        if(n_BlockSize) {</a>
<a name="ln694">            archive_write_set_bytes_per_block(m_ArchiveWrite.data(), n_BlockSize);</a>
<a name="ln695">        }</a>
<a name="ln696"> </a>
<a name="ln697">        if(!b_MemoryMode) {</a>
<a name="ln698">            // Finally open the write archive using the handle of the Temporary file.</a>
<a name="ln699">            if(archive_write_open_fd(m_ArchiveWrite.data(),</a>
<a name="ln700">                                     m_TemporaryFile-&gt;handle()) != ARCHIVE_OK) {</a>
<a name="ln701">                m_ArchiveWrite.clear();</a>
<a name="ln702">                emit error(ArchiveWriteOpenError, m_TemporaryFile-&gt;fileName());</a>
<a name="ln703">                return ArchiveWriteOpenError;</a>
<a name="ln704">            }</a>
<a name="ln705">        } else {</a>
<a name="ln706">            if(archiveWriteOpenQIODevice(m_ArchiveWrite.data(),</a>
<a name="ln707">                                         (QIODevice*)m_Buffer.data()) != ARCHIVE_OK) {</a>
<a name="ln708"> </a>
<a name="ln709">                m_ArchiveWrite.clear();</a>
<a name="ln710">                emit error(ArchiveWriteOpenError, QString());</a>
<a name="ln711">                return ArchiveWriteOpenError;</a>
<a name="ln712">            }</a>
<a name="ln713">        }</a>
<a name="ln714"> </a>
<a name="ln715">        n_TotalEntries = m_ConfirmedFiles-&gt;size(); // for reporting progress.</a>
<a name="ln716">    }</a>
<a name="ln717"> </a>
<a name="ln718">    // Start compressing files.</a>
<a name="ln719">    while(!m_ConfirmedFiles-&gt;isEmpty()) {</a>
<a name="ln720">        auto node = m_ConfirmedFiles-&gt;first();</a>
<a name="ln721">        int r;</a>
<a name="ln722">        std::size_t len;</a>
<a name="ln723">        char buff[16384];</a>
<a name="ln724"> </a>
<a name="ln725">        if(!node-&gt;isInMemory) {</a>
<a name="ln726">            // TODO:</a>
<a name="ln727">            //	Implement a failsafe copy mechanism.</a>
<a name="ln728">            //</a>
<a name="ln729">            // Note:</a>
<a name="ln730">            // Down below implementation is nearly good but</a>
<a name="ln731">            // not very robust and thus needs a good implementation.</a>
<a name="ln732">            auto disk = QSharedPointer&lt;struct archive&gt;(</a>
<a name="ln733">                            archive_read_disk_new(), ArchiveReadDestructor);</a>
<a name="ln734">            archive_read_disk_set_standard_lookup(disk.data());</a>
<a name="ln735"> </a>
<a name="ln736">            r = archive_read_disk_open(disk.data(),</a>
<a name="ln737">                                       QFile::encodeName(/*file path = */node-&gt;path).constData());</a>
<a name="ln738"> </a>
<a name="ln739">            if(r != ARCHIVE_OK) {</a>
<a name="ln740">                emit error(DiskOpenError, node-&gt;path);</a>
<a name="ln741">                return DiskOpenError;</a>
<a name="ln742">            }</a>
<a name="ln743"> </a>
<a name="ln744">            for (;;) {</a>
<a name="ln745">                auto entry = QSharedPointer&lt;struct archive_entry&gt;(</a>
<a name="ln746">                                 archive_entry_new(), ArchiveEntryDestructor);</a>
<a name="ln747">                r = archive_read_next_header2(disk.data(), entry.data());</a>
<a name="ln748"> </a>
<a name="ln749">                if (r == ARCHIVE_EOF) {</a>
<a name="ln750">                    break;</a>
<a name="ln751">                }</a>
<a name="ln752"> </a>
<a name="ln753">                if (r != ARCHIVE_OK) {</a>
<a name="ln754">                    emit error(DiskReadError, node-&gt;path);</a>
<a name="ln755">                    return DiskReadError;</a>
<a name="ln756">                }</a>
<a name="ln757"> </a>
<a name="ln758">                archive_read_disk_descend(disk.data());</a>
<a name="ln759">                archive_entry_set_pathname(entry.data(), (node-&gt;entry).toUtf8().constData());</a>
<a name="ln760">                r = archive_write_header(m_ArchiveWrite.data(), entry.data());</a>
<a name="ln761"> </a>
<a name="ln762">                if (r == ARCHIVE_FATAL) {</a>
<a name="ln763">                    emit error(ArchiveFatalError, node-&gt;path);</a>
<a name="ln764">                    return ArchiveFatalError;</a>
<a name="ln765">                }</a>
<a name="ln766">                if (r &gt; ARCHIVE_FAILED) {</a>
<a name="ln767">                    QScopedPointer&lt;QFile&gt; file(new QFile(node-&gt;path));</a>
<a name="ln768">                    if(!file-&gt;open(QIODevice::ReadOnly)) {</a>
<a name="ln769">                        emit error(DiskOpenError, node-&gt;path);</a>
<a name="ln770">                        return DiskOpenError;</a>
<a name="ln771">                    }</a>
<a name="ln772">                    len = file-&gt;read(buff, sizeof(buff));</a>
<a name="ln773">                    while (len &gt; 0) {</a>
<a name="ln774">                        archive_write_data(m_ArchiveWrite.data(), buff, len);</a>
<a name="ln775">                        n_BytesProcessed += len;</a>
<a name="ln776"> </a>
<a name="ln777">                        emit progress(node-&gt;entry,</a>
<a name="ln778">                                      (n_TotalEntries - (m_ConfirmedFiles-&gt;size() - 1)),</a>
<a name="ln779">                                      n_TotalEntries, n_BytesProcessed, n_BytesTotal);</a>
<a name="ln780"> </a>
<a name="ln781">                        QCoreApplication::processEvents();</a>
<a name="ln782">                        len = file-&gt;read(buff, sizeof(buff));</a>
<a name="ln783">                    }</a>
<a name="ln784">                    file-&gt;close();</a>
<a name="ln785">                } else {</a>
<a name="ln786">                    emit error(ArchiveHeaderWriteError, node-&gt;path);</a>
<a name="ln787">                    return ArchiveHeaderWriteError;</a>
<a name="ln788">                }</a>
<a name="ln789"> </a>
<a name="ln790">                QCoreApplication::processEvents();</a>
<a name="ln791">            }</a>
<a name="ln792">        } else {</a>
<a name="ln793">            auto entry = QSharedPointer&lt;struct archive_entry&gt;(</a>
<a name="ln794">                             archive_entry_new(),</a>
<a name="ln795">                             ArchiveEntryDestructor);</a>
<a name="ln796"> </a>
<a name="ln797">            // Setup archive entry.</a>
<a name="ln798">	    auto datetime = QDateTime::currentDateTime();</a>
<a name="ln799">            archive_entry_set_pathname(entry.data(), (node-&gt;entry).toUtf8().constData());</a>
<a name="ln800">            archive_entry_set_filetype(entry.data(), AE_IFREG);</a>
<a name="ln801">            archive_entry_set_size(entry.data(), (node-&gt;io)-&gt;size());</a>
<a name="ln802">	    archive_entry_set_atime(entry.data(), (time_t)datetime.currentSecsSinceEpoch(), 0);</a>
<a name="ln803">	    archive_entry_set_mtime(entry.data(), (time_t)datetime.currentSecsSinceEpoch(), 0);</a>
<a name="ln804">	    archive_entry_set_birthtime(entry.data(), (time_t)datetime.currentSecsSinceEpoch(), 0);</a>
<a name="ln805"> </a>
<a name="ln806">            (node-&gt;io)-&gt;seek(0);</a>
<a name="ln807"> </a>
<a name="ln808">            // Write entry to memory</a>
<a name="ln809">            r = archive_write_header(m_ArchiveWrite.data(), entry.data());</a>
<a name="ln810"> </a>
<a name="ln811">            if (r == ARCHIVE_FATAL) {</a>
<a name="ln812">                emit error(ArchiveFatalError, node-&gt;entry);</a>
<a name="ln813">                return ArchiveFatalError;</a>
<a name="ln814">            }</a>
<a name="ln815"> </a>
<a name="ln816">            if (r &gt; ARCHIVE_FAILED) {</a>
<a name="ln817">                len = (node-&gt;io)-&gt;read(buff, sizeof(buff));</a>
<a name="ln818">                while (len &gt; 0) {</a>
<a name="ln819">                    archive_write_data(m_ArchiveWrite.data(), buff, len);</a>
<a name="ln820">                    n_BytesProcessed += len;</a>
<a name="ln821"> </a>
<a name="ln822">                    emit progress(node-&gt;entry,</a>
<a name="ln823">                                  (n_TotalEntries - (m_ConfirmedFiles-&gt;size() - 1)),</a>
<a name="ln824">                                  n_TotalEntries, n_BytesProcessed, n_BytesTotal);</a>
<a name="ln825"> </a>
<a name="ln826">                    QCoreApplication::processEvents();</a>
<a name="ln827">                    len = (node-&gt;io)-&gt;read(buff, sizeof(buff));</a>
<a name="ln828">                }</a>
<a name="ln829">            } else {</a>
<a name="ln830">                emit error(ArchiveHeaderWriteError, node-&gt;entry);</a>
<a name="ln831">                return ArchiveHeaderWriteError;</a>
<a name="ln832">            }</a>
<a name="ln833">        }</a>
<a name="ln834"> </a>
<a name="ln835">        m_ConfirmedFiles-&gt;removeFirst();</a>
<a name="ln836"> </a>
<a name="ln837">        emit progress(node-&gt;entry,</a>
<a name="ln838">                      (n_TotalEntries - m_ConfirmedFiles-&gt;size()),</a>
<a name="ln839">                      n_TotalEntries, n_BytesProcessed, n_BytesTotal);</a>
<a name="ln840"> </a>
<a name="ln841">	delete node;</a>
<a name="ln842"> </a>
<a name="ln843">        QCoreApplication::processEvents();</a>
<a name="ln844">        if(b_PauseRequested) {</a>
<a name="ln845">            b_PauseRequested = false;</a>
<a name="ln846">            return OperationPaused;</a>
<a name="ln847">        }</a>
<a name="ln848"> </a>
<a name="ln849">        if(b_CancelRequested) {</a>
<a name="ln850">            b_CancelRequested = false;</a>
<a name="ln851">            m_ConfirmedFiles-&gt;clear();</a>
<a name="ln852">            m_ArchiveWrite.clear();</a>
<a name="ln853">            return OperationCanceled;</a>
<a name="ln854">        }</a>
<a name="ln855">    }</a>
<a name="ln856">    m_ArchiveWrite.clear();</a>
<a name="ln857">    return NoError;</a>
<a name="ln858">}</a>

</code></pre>
<div class="balloon" rel="356"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1048/" target="_blank">V1048</a> The 'b_Started' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
