
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>qarchivediskcompressor_p.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &lt;QCoreApplication&gt;</a>
<a name="ln2">#include &lt;QDateTime&gt;</a>
<a name="ln3">#include &lt;QFileInfo&gt;</a>
<a name="ln4">#include &lt;QVector&gt;</a>
<a name="ln5">#include &lt;QDir&gt;</a>
<a name="ln6">#include &lt;QDebug&gt;</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;qarchivediskcompressor_p.hpp&gt;</a>
<a name="ln9">#include &lt;qarchiveutils_p.hpp&gt;</a>
<a name="ln10">#include &lt;qarchive_enums.hpp&gt;</a>
<a name="ln11">#include &lt;QElapsedTimer&gt;</a>
<a name="ln12"> </a>
<a name="ln13">extern &quot;C&quot; {</a>
<a name="ln14">#include &lt;archive.h&gt;</a>
<a name="ln15">#include &lt;archive_entry.h&gt;</a>
<a name="ln16">#include &lt;fcntl.h&gt;</a>
<a name="ln17">#include &lt;stdio.h&gt;</a>
<a name="ln18">#include &lt;stdlib.h&gt;</a>
<a name="ln19">#include &lt;string.h&gt;</a>
<a name="ln20">#include &lt;sys/types.h&gt;</a>
<a name="ln21">#include &lt;sys/stat.h&gt;</a>
<a name="ln22">}</a>
<a name="ln23"> </a>
<a name="ln24">using namespace QArchive;</a>
<a name="ln25"> </a>
<a name="ln26">// DiskCompressorPrivate is the private class which handles the</a>
<a name="ln27">// compression of data to disk.</a>
<a name="ln28">// It can compress data in all formats of archive supported by libarchive.</a>
<a name="ln29">// However there is a method to set password for archives , Only</a>
<a name="ln30">// ZIP Format is currently supported for encrypting archives with a user given.</a>
<a name="ln31">DiskCompressorPrivate::DiskCompressorPrivate()</a>
<a name="ln32">    : QObject() {</a>
<a name="ln33">    m_TemporaryFile.reset(new QSaveFile);</a>
<a name="ln34">    m_StaggedFiles.reset(new QLinkedList&lt;QPair&lt;QString, QString&gt;&gt;);</a>
<a name="ln35">    m_ConfirmedFiles.reset(new QLinkedList&lt;QPair&lt;QString, QString&gt;&gt;);</a>
<a name="ln36">}</a>
<a name="ln37"> </a>
<a name="ln38">DiskCompressorPrivate::~DiskCompressorPrivate() {</a>
<a name="ln39">    m_ArchiveWrite.clear();</a>
<a name="ln40">}</a>
<a name="ln41"> </a>
<a name="ln42">// Set the filename for the archive to written on disk , the filename can</a>
<a name="ln43">// be relative or absolute as long it is not existing already or does</a>
<a name="ln44">// not have the permission to write.</a>
<a name="ln45">void DiskCompressorPrivate::setFileName(const QString &amp;fileName) {</a>
<a name="ln46">    if(b_Started || b_Paused) {</a>
<a name="ln47">        return;</a>
<a name="ln48">    }</a>
<a name="ln49">    m_TemporaryFile-&gt;setFileName(fileName);</a>
<a name="ln50">    return;</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53">// Explicitly set the format of the archive , when the format is explicitly set</a>
<a name="ln54">// then even if the filename corresponds to some other format , the compressor will</a>
<a name="ln55">// only compress the data in the given archive format.</a>
<a name="ln56">void DiskCompressorPrivate::setArchiveFormat(short format) {</a>
<a name="ln57">    if(b_Started || b_Paused) {</a>
<a name="ln58">        return;</a>
<a name="ln59">    }</a>
<a name="ln60">    m_ArchiveFormat = format;</a>
<a name="ln61">    return;</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">// Only used for ZIP Archives , other formats are ignored.</a>
<a name="ln65">void DiskCompressorPrivate::setPassword(const QString &amp;passwd) {</a>
<a name="ln66">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln67">    if(b_Started || b_Paused) {</a>
<a name="ln68">        return;</a>
<a name="ln69">    }</a>
<a name="ln70">    m_Password = passwd;</a>
<a name="ln71">#else</a>
<a name="ln72">    (void)passwd;</a>
<a name="ln73">#endif</a>
<a name="ln74">    return;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">void DiskCompressorPrivate::setBlockSize(int size) {</a>
<a name="ln78">    if(b_Started || b_Paused) {</a>
<a name="ln79">        return;</a>
<a name="ln80">    }</a>
<a name="ln81">    n_BlockSize = size;</a>
<a name="ln82">    return;</a>
<a name="ln83">}</a>
<a name="ln84"> </a>
<a name="ln85">void DiskCompressorPrivate::addFiles(const QString &amp;file) {</a>
<a name="ln86">    if(b_Started || b_Paused) {</a>
<a name="ln87">        return;</a>
<a name="ln88">    }</a>
<a name="ln89">    QPair&lt;QString, QString&gt; node(file, file);</a>
<a name="ln90">    m_StaggedFiles-&gt;append(node);</a>
<a name="ln91">    return;</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94">void DiskCompressorPrivate::addFiles(const QStringList &amp;files) {</a>
<a name="ln95">    if(b_Started || b_Paused) {</a>
<a name="ln96">        return;</a>
<a name="ln97">    }</a>
<a name="ln98">    for(auto i = 0; i &lt; files.size(); ++i) {</a>
<a name="ln99">        QPair&lt;QString, QString&gt; node(files.at(i), files.at(i));</a>
<a name="ln100">        if(m_StaggedFiles-&gt;contains(node)) {</a>
<a name="ln101">            continue;</a>
<a name="ln102">        }</a>
<a name="ln103">        m_StaggedFiles-&gt;append(node);</a>
<a name="ln104">    }</a>
<a name="ln105">    return;</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">// Adds a single file and uses a custom entry name with </a>
<a name="ln109">// respect to the given data.</a>
<a name="ln110">void DiskCompressorPrivate::addFiles(const QString &amp;entryName, const QString &amp;file) {</a>
<a name="ln111">    if(b_Started || b_Paused) {</a>
<a name="ln112">        return;</a>
<a name="ln113">    }</a>
<a name="ln114">    QPair&lt;QString, QString&gt; node(entryName, file);</a>
<a name="ln115">    if(m_StaggedFiles-&gt;contains(node)) {</a>
<a name="ln116">        return;</a>
<a name="ln117">    }</a>
<a name="ln118">    m_StaggedFiles-&gt;append(node);</a>
<a name="ln119">    return;</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">// Adds multiple files and uses a corresponding list of </a>
<a name="ln123">// entry names with respect to the given data.</a>
<a name="ln124">void DiskCompressorPrivate::addFiles(const QStringList &amp;entryNames, const QStringList &amp;files) {</a>
<a name="ln125">    if(b_Started || b_Paused) {</a>
<a name="ln126">        return;</a>
<a name="ln127">    }</a>
<a name="ln128">    if(entryNames.size() != files.size()) {</a>
<a name="ln129">        return;</a>
<a name="ln130">    }</a>
<a name="ln131">    for(auto i = 0; i &lt; files.size(); ++i) {</a>
<a name="ln132">        QPair&lt;QString, QString&gt; node(entryNames.at(i), files.at(i));</a>
<a name="ln133">        if(m_StaggedFiles-&gt;contains(node)) {</a>
<a name="ln134">            continue;</a>
<a name="ln135">        }</a>
<a name="ln136">        m_StaggedFiles-&gt;append(node);</a>
<a name="ln137">    }</a>
<a name="ln138">    return;</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141">void DiskCompressorPrivate::removeFiles(const QString &amp;file) {</a>
<a name="ln142">    if(b_Started || b_Paused) {</a>
<a name="ln143">        return;</a>
<a name="ln144">    }</a>
<a name="ln145">    QPair&lt;QString, QString&gt; node(file, file);</a>
<a name="ln146">    m_StaggedFiles-&gt;removeAll(node);</a>
<a name="ln147">    return;</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">void DiskCompressorPrivate::removeFiles(const QStringList &amp;files) {</a>
<a name="ln151">    if(b_Started || b_Paused) {</a>
<a name="ln152">        return;</a>
<a name="ln153">    }</a>
<a name="ln154">    for(auto i = 0; i &lt; files.size() ; ++i) {</a>
<a name="ln155">        QPair&lt;QString, QString&gt; node(files.at(i), files.at(i));</a>
<a name="ln156">        m_StaggedFiles-&gt;removeAll(node);</a>
<a name="ln157">    }</a>
<a name="ln158">    return;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">void DiskCompressorPrivate::removeFiles(const QString &amp;entryName, const QString &amp;file) {</a>
<a name="ln162">    if(b_Started || b_Paused) {</a>
<a name="ln163">        return;</a>
<a name="ln164">    }</a>
<a name="ln165">    QPair&lt;QString, QString&gt; node(entryName, file);</a>
<a name="ln166">    m_StaggedFiles-&gt;removeAll(node);</a>
<a name="ln167">    return;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">void DiskCompressorPrivate::removeFiles(const QStringList &amp;entryNames, const QStringList &amp;files) {</a>
<a name="ln171">    if(b_Started || b_Paused) {</a>
<a name="ln172">        return;</a>
<a name="ln173">    }</a>
<a name="ln174">    if(entryNames.size() != files.size()) {</a>
<a name="ln175">        return;</a>
<a name="ln176">    }</a>
<a name="ln177"> </a>
<a name="ln178">    for(auto i = 0; i &lt; files.size() ; ++i) {</a>
<a name="ln179">        QPair&lt;QString, QString&gt; node(entryNames.at(i), files.at(i));</a>
<a name="ln180">        m_StaggedFiles-&gt;removeAll(node);</a>
<a name="ln181">    }</a>
<a name="ln182">    return;</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">/* clears internal cache. */</a>
<a name="ln186">void DiskCompressorPrivate::clear() {</a>
<a name="ln187">    if(b_Started) {</a>
<a name="ln188">        return;</a>
<a name="ln189">    }</a>
<a name="ln190">    b_PauseRequested = b_CancelRequested = b_Paused = b_Started = b_Finished = false;</a>
<a name="ln191">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln192">    m_Password.clear();</a>
<a name="ln193">#endif</a>
<a name="ln194"> </a>
<a name="ln195">    m_ArchiveFormat = 0;</a>
<a name="ln196">    n_BlockSize = 10240;</a>
<a name="ln197"> </a>
<a name="ln198">    // TODO: do we need to reset n_BytesTotal here?</a>
<a name="ln199">    n_BytesProcessed = 0;</a>
<a name="ln200">    n_BytesTotal = 0;</a>
<a name="ln201"> </a>
<a name="ln202">    m_ConfirmedFiles-&gt;clear();</a>
<a name="ln203">    m_StaggedFiles-&gt;clear();</a>
<a name="ln204"> </a>
<a name="ln205">    m_TemporaryFile.reset(new QSaveFile);</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">// Starts the compression.</a>
<a name="ln209">void DiskCompressorPrivate::start() {</a>
<a name="ln210">    if(b_Started || b_Paused) {</a>
<a name="ln211">        return;</a>
<a name="ln212">    } else if(m_TemporaryFile-&gt;fileName().isEmpty()) {</a>
<a name="ln213">        emit error(ArchiveFileNameNotGiven, QString());</a>
<a name="ln214">        return;</a>
<a name="ln215">    } else if(QFileInfo::exists(m_TemporaryFile-&gt;fileName())) {</a>
<a name="ln216">        emit error(ArchiveFileAlreadyExists, m_TemporaryFile-&gt;fileName());</a>
<a name="ln217">        return;</a>
<a name="ln218">    } else if(m_StaggedFiles-&gt;isEmpty()) {</a>
<a name="ln219">        emit error(NoFilesToCompress, m_TemporaryFile-&gt;fileName());</a>
<a name="ln220">        return;</a>
<a name="ln221">    } else {</a>
<a name="ln222">        // Guess Archive Format if not given.</a>
<a name="ln223">        if(!m_ArchiveFormat) { // if ArchiveFormat == 0 then no format is set.</a>
<a name="ln224">            if(!guessArchiveFormat()) {</a>
<a name="ln225">                m_ArchiveFormat = ZipFormat; // Default format.</a>
<a name="ln226">            }</a>
<a name="ln227">        }</a>
<a name="ln228"> </a>
<a name="ln229">        /// Confirm files.</a>
<a name="ln230">        n_BytesTotal = 0;</a>
<a name="ln231">        if(!confirmFiles()) {</a>
<a name="ln232">            return;</a>
<a name="ln233">        }</a>
<a name="ln234">    }</a>
<a name="ln235"> </a>
<a name="ln236">    b_Started = true;</a>
<a name="ln237">    emit started();</a>
<a name="ln238"> </a>
<a name="ln239">    n_BytesProcessed = 0;</a>
<a name="ln240"> </a>
<a name="ln241">    short ret = compress();</a>
<a name="ln242">    if(ret == NoError) {</a>
<a name="ln243">        b_Started = false;</a>
<a name="ln244">        b_Finished = true;</a>
<a name="ln245">        m_TemporaryFile-&gt;commit();</a>
<a name="ln246">        emit finished();</a>
<a name="ln247">    } else if(ret == OperationCanceled) {</a>
<a name="ln248">        b_Started = false;</a>
<a name="ln249">        emit canceled();</a>
<a name="ln250">    } else if(ret == OperationPaused) {</a>
<a name="ln251">        b_Started = false;</a>
<a name="ln252">        b_Paused = true;</a>
<a name="ln253">        emit paused();</a>
<a name="ln254">    }</a>
<a name="ln255">    return;</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">void DiskCompressorPrivate::resume() {</a>
<a name="ln259">    if(!b_Paused || b_Finished) {</a>
<a name="ln260">        return;</a>
<a name="ln261">    }</a>
<a name="ln262">    b_Paused = false;</a>
<a name="ln263">    b_Started = true;</a>
<a name="ln264">    emit resumed();</a>
<a name="ln265"> </a>
<a name="ln266">    short ret = compress();</a>
<a name="ln267">    if(ret == NoError) {</a>
<a name="ln268">        b_Started = false;</a>
<a name="ln269">        b_Finished = true;</a>
<a name="ln270">        m_TemporaryFile-&gt;commit();</a>
<a name="ln271">        emit finished();</a>
<a name="ln272">    } else if(ret == OperationCanceled) {</a>
<a name="ln273">        b_Started = false;</a>
<a name="ln274">        emit canceled();</a>
<a name="ln275">    } else if(ret == OperationPaused) {</a>
<a name="ln276">        b_Started = false;</a>
<a name="ln277">        b_Paused = true;</a>
<a name="ln278">        emit paused();</a>
<a name="ln279">    }</a>
<a name="ln280">    return;</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">void DiskCompressorPrivate::pause() {</a>
<a name="ln284">    if(!b_Started || b_Finished || b_Paused) {</a>
<a name="ln285">        return;</a>
<a name="ln286">    }</a>
<a name="ln287">    b_PauseRequested = true;</a>
<a name="ln288">    return;</a>
<a name="ln289">}</a>
<a name="ln290"> </a>
<a name="ln291">// Cancels the current compression process, if the compression process is</a>
<a name="ln292">// paused then the compression cannot be canceled.</a>
<a name="ln293">void DiskCompressorPrivate::cancel() {</a>
<a name="ln294">    if(!b_Started || b_Finished || b_Paused) {</a>
<a name="ln295">        return;</a>
<a name="ln296">    }</a>
<a name="ln297">    b_CancelRequested = true;</a>
<a name="ln298">    return;</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">// Guesses the archive format from the given archive filename , on success</a>
<a name="ln302">// this returns true or vice-versa.</a>
<a name="ln303">bool DiskCompressorPrivate::guessArchiveFormat() {</a>
<a name="ln304">    if(m_TemporaryFile-&gt;fileName().isEmpty()) {</a>
<a name="ln305">        return false;</a>
<a name="ln306">    }</a>
<a name="ln307"> </a>
<a name="ln308">    auto ext = QFileInfo(m_TemporaryFile-&gt;fileName()).suffix().toLower();</a>
<a name="ln309">    if(ext == &quot;bz&quot;) {</a>
<a name="ln310">        m_ArchiveFormat = BZipFormat;</a>
<a name="ln311">    } else if(ext == &quot;bz2&quot;) {</a>
<a name="ln312">        m_ArchiveFormat = BZip2Format;</a>
<a name="ln313">    } else if(ext == &quot;gz&quot;) {</a>
<a name="ln314">        m_ArchiveFormat = GZipFormat;</a>
<a name="ln315">    } else if(ext == &quot;xz&quot;) {</a>
<a name="ln316">        m_ArchiveFormat = XzFormat;</a>
<a name="ln317">    } else if(ext == &quot;tar&quot;) {</a>
<a name="ln318">        m_ArchiveFormat = TarFormat;</a>
<a name="ln319">    } else if(ext == &quot;xar&quot;) {</a>
<a name="ln320">        m_ArchiveFormat = XarFormat;</a>
<a name="ln321">    } else if(ext == &quot;zip&quot;) {</a>
<a name="ln322">        m_ArchiveFormat = ZipFormat;</a>
<a name="ln323">    } else if(ext == &quot;7z&quot;) {</a>
<a name="ln324">        m_ArchiveFormat = SevenZipFormat;</a>
<a name="ln325">    } else {</a>
<a name="ln326">        m_ArchiveFormat = 0;</a>
<a name="ln327">        return false;</a>
<a name="ln328">    }</a>
<a name="ln329"> </a>
<a name="ln330">    return true;</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333">// Confirms all the files that are stagged for compression , Returns true</a>
<a name="ln334">// on success and vice-versa.</a>
<a name="ln335">// This populates m_ConfirmedFiles linked list with all the files added ,</a>
<a name="ln336">// Directory's files will be recursively added.</a>
<a name="ln337">bool DiskCompressorPrivate::confirmFiles() {</a>
<a name="ln338">    m_ConfirmedFiles-&gt;clear();</a>
<a name="ln339">    for(auto iter = m_StaggedFiles-&gt;begin() ; iter != m_StaggedFiles-&gt;end() ; ++iter) {</a>
<a name="ln340">        auto node = *iter;</a>
<a name="ln341">        QFileInfo info(/* file path given by the user = */node.second);</a>
<a name="ln342"> </a>
<a name="ln343">        // Check if the file exists.</a>
<a name="ln344">        if(!info.exists()) {</a>
<a name="ln345">            emit error(FileDoesNotExist, info.filePath());</a>
<a name="ln346">            return false;</a>
<a name="ln347">        }</a>
<a name="ln348"> </a>
<a name="ln349">        // Check permission to read.</a>
<a name="ln350">        if(!info.isReadable()) {</a>
<a name="ln351">            emit error(NoPermissionToReadFile, info.filePath());</a>
<a name="ln352">            return false;</a>
<a name="ln353">        }</a>
<a name="ln354"> </a>
<a name="ln355"> </a>
<a name="ln356">        // Check if it is file or a directory ,</a>
<a name="ln357">        // if directory then add files in directory</a>
<a name="ln358">        // recursively.</a>
<a name="ln359">        if(info.isDir()) {</a>
<a name="ln360">            QVector&lt;QString&gt; dirList;</a>
<a name="ln361">            dirList.append(info.filePath());</a>
<a name="ln362">            bool replace = (node.first != node.second);</a>
<a name="ln363"> </a>
<a name="ln364">            while(!dirList.isEmpty()) {</a>
<a name="ln365">                QDir dir(dirList.takeFirst());</a>
<a name="ln366">                QFileInfoList list = dir.entryInfoList(QDir::AllEntries | QDir::NoDotAndDotDot | QDir::Hidden);</a>
<a name="ln367">                for (int i = 0; i &lt; list.size(); i++) {</a>
<a name="ln368">                    if(list.at(i).isDir()) {</a>
<a name="ln369">                        dirList.append(list.at(i).filePath());</a>
<a name="ln370">                        continue;</a>
<a name="ln371">                    }</a>
<a name="ln372">                    QString file = list.at(i).filePath();</a>
<a name="ln373">                    QPair&lt;QString, QString&gt; fileNode;</a>
<a name="ln374">                    if(replace) {</a>
<a name="ln375">                        fileNode.first = file.replace(node.second, node.first);</a>
<a name="ln376">                    } else {</a>
<a name="ln377">                        fileNode.first = file;</a>
<a name="ln378">                    }</a>
<a name="ln379">                    fileNode.second = file;</a>
<a name="ln380">                    m_ConfirmedFiles-&gt;append(fileNode);</a>
<a name="ln381"> </a>
<a name="ln382">                    QFileInfo info(file);</a>
<a name="ln383">                    n_BytesTotal += info.size();</a>
<a name="ln384">                }</a>
<a name="ln385">            }</a>
<a name="ln386">        } else { // Add it to the confirmed list.</a>
<a name="ln387">            if(node.first == node.second) {</a>
<a name="ln388">                node.first = info.filePath();</a>
<a name="ln389">            }</a>
<a name="ln390">            node.second = info.filePath();</a>
<a name="ln391">            m_ConfirmedFiles-&gt;append(node);</a>
<a name="ln392">            n_BytesTotal += info.size();</a>
<a name="ln393">        }</a>
<a name="ln394">    }</a>
<a name="ln395">    return true;</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">// Does the compression and also resumes it if called twice.</a>
<a name="ln399">short DiskCompressorPrivate::compress() {</a>
<a name="ln400">    if(m_ArchiveWrite.isNull()) {</a>
<a name="ln401">        /// Open Temporary file for write.</a>
<a name="ln402">        if(!m_TemporaryFile-&gt;open(QIODevice::WriteOnly)) {</a>
<a name="ln403">            emit error(ArchiveWriteOpenError, m_TemporaryFile-&gt;fileName());</a>
<a name="ln404">            return ArchiveWriteOpenError;</a>
<a name="ln405">        }</a>
<a name="ln406"> </a>
<a name="ln407">        m_ArchiveWrite = QSharedPointer&lt;struct archive&gt;(</a>
<a name="ln408">				archive_write_new(), ArchiveWriteDestructor);</a>
<a name="ln409">        if(m_ArchiveWrite.isNull()) {</a>
<a name="ln410">            emit error(NotEnoughMemory, m_TemporaryFile-&gt;fileName());</a>
<a name="ln411">            return NotEnoughMemory;</a>
<a name="ln412">        }</a>
<a name="ln413"> </a>
<a name="ln414">        switch (m_ArchiveFormat) {</a>
<a name="ln415">        case BZipFormat:</a>
<a name="ln416">        case BZip2Format:</a>
<a name="ln417">            archive_write_add_filter_bzip2(m_ArchiveWrite.data());</a>
<a name="ln418">            archive_write_set_format_ustar(m_ArchiveWrite.data());</a>
<a name="ln419">            break;</a>
<a name="ln420">        case GZipFormat:</a>
<a name="ln421">            archive_write_add_filter_gzip(m_ArchiveWrite.data());</a>
<a name="ln422">            archive_write_set_format_ustar(m_ArchiveWrite.data());</a>
<a name="ln423">            break;</a>
<a name="ln424">        case XzFormat:</a>
<a name="ln425">            archive_write_add_filter_xz(m_ArchiveWrite.data());</a>
<a name="ln426">            archive_write_set_format_ustar(m_ArchiveWrite.data());</a>
<a name="ln427">            break;</a>
<a name="ln428">        case TarFormat:</a>
<a name="ln429">            archive_write_add_filter_none(m_ArchiveWrite.data());</a>
<a name="ln430">            archive_write_set_format_ustar(m_ArchiveWrite.data());</a>
<a name="ln431">            break;</a>
<a name="ln432">        case XarFormat:</a>
<a name="ln433">            archive_write_add_filter_none(m_ArchiveWrite.data());</a>
<a name="ln434">            archive_write_set_format_xar(m_ArchiveWrite.data());</a>
<a name="ln435">            break;</a>
<a name="ln436">        case SevenZipFormat:</a>
<a name="ln437">            archive_write_add_filter_none(m_ArchiveWrite.data());</a>
<a name="ln438">            archive_write_set_format_7zip(m_ArchiveWrite.data());</a>
<a name="ln439">            break;</a>
<a name="ln440">        case ZipFormat:</a>
<a name="ln441">        default:</a>
<a name="ln442">            archive_write_add_filter_none(m_ArchiveWrite.data());</a>
<a name="ln443">            archive_write_set_format_zip(m_ArchiveWrite.data());</a>
<a name="ln444">            break;</a>
<a name="ln445">        }</a>
<a name="ln446"> </a>
<a name="ln447">        // Set Password if the format is Zip and a password is given by the user.</a>
<a name="ln448">        //</a>
<a name="ln449">        // Note:</a>
<a name="ln450">        // Currently only Zip format is officially supported by libarchive for the</a>
<a name="ln451">        // ability to use passwords and thus until the user uses Zip format , the</a>
<a name="ln452">        // password even if given is ignored.</a>
<a name="ln453">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln454">        if(!m_Password.isEmpty() &amp;&amp; m_ArchiveFormat == ZipFormat) {</a>
<a name="ln455">            archive_write_set_passphrase(m_ArchiveWrite.data(), m_Password.toUtf8().constData());</a>
<a name="ln456">            archive_write_set_options(m_ArchiveWrite.data(), &quot;zip:encryption=traditional&quot;);</a>
<a name="ln457">        }</a>
<a name="ln458">#endif</a>
<a name="ln459"> </a>
<a name="ln460">        if(n_BlockSize) {</a>
<a name="ln461">            archive_write_set_bytes_per_block(m_ArchiveWrite.data(), n_BlockSize);</a>
<a name="ln462">        }</a>
<a name="ln463"> </a>
<a name="ln464">        // Finally open the write archive using the handle of the Temporary file.</a>
<a name="ln465">        if(archive_write_open_fd(m_ArchiveWrite.data(),</a>
<a name="ln466">				m_TemporaryFile-&gt;handle()) != ARCHIVE_OK) {</a>
<a name="ln467">            m_ArchiveWrite.clear();</a>
<a name="ln468">            emit error(ArchiveWriteOpenError, m_TemporaryFile-&gt;fileName());</a>
<a name="ln469">            return ArchiveWriteOpenError;</a>
<a name="ln470">        }</a>
<a name="ln471"> </a>
<a name="ln472">        n_TotalEntries = m_ConfirmedFiles-&gt;size(); // for reporting progress.</a>
<a name="ln473">    }</a>
<a name="ln474"> </a>
<a name="ln475">    // Start compressing files.</a>
<a name="ln476">    while(!m_ConfirmedFiles-&gt;isEmpty()) {</a>
<a name="ln477">        auto node = m_ConfirmedFiles-&gt;takeFirst();</a>
<a name="ln478">        // TODO:</a>
<a name="ln479">        //	Implement a failsafe copy mechanism.</a>
<a name="ln480">        //</a>
<a name="ln481">        // Note:</a>
<a name="ln482">        // Down below implementation is nearly good but</a>
<a name="ln483">        // not very robust and thus needs a good implementation.</a>
<a name="ln484">        int r;</a>
<a name="ln485">        std::size_t len;</a>
<a name="ln486">        char buff[16384]; /* Default buffer size */</a>
<a name="ln487"> </a>
<a name="ln488">        auto disk = QSharedPointer&lt;struct archive&gt;(</a>
<a name="ln489">			archive_read_disk_new(), ArchiveReadDestructor);</a>
<a name="ln490">        archive_read_disk_set_standard_lookup(disk.data());</a>
<a name="ln491"> </a>
<a name="ln492">        r = archive_read_disk_open(disk.data(),</a>
<a name="ln493">			QFile::encodeName(/*file path = */node.second).constData());</a>
<a name="ln494">        if(r != ARCHIVE_OK) {</a>
<a name="ln495">            emit error(DiskOpenError, node.second);</a>
<a name="ln496">            return DiskOpenError;</a>
<a name="ln497">        }</a>
<a name="ln498"> </a>
<a name="ln499">        for (;;) {</a>
<a name="ln500">            auto entry = QSharedPointer&lt;struct archive_entry&gt;(</a>
<a name="ln501">			    archive_entry_new(), ArchiveEntryDestructor);</a>
<a name="ln502">            r = archive_read_next_header2(disk.data(), entry.data());</a>
<a name="ln503">            if (r == ARCHIVE_EOF) {</a>
<a name="ln504">                break;</a>
<a name="ln505">            }</a>
<a name="ln506">            if (r != ARCHIVE_OK) {</a>
<a name="ln507">                emit error(DiskReadError, node.second);</a>
<a name="ln508">                return DiskReadError;</a>
<a name="ln509">            }</a>
<a name="ln510"> </a>
<a name="ln511">            archive_read_disk_descend(disk.data());</a>
<a name="ln512">            archive_entry_set_pathname(entry.data(), (node.first).toUtf8().constData());</a>
<a name="ln513">            r = archive_write_header(m_ArchiveWrite.data(), entry.data());</a>
<a name="ln514"> </a>
<a name="ln515">            if (r == ARCHIVE_FATAL) {</a>
<a name="ln516">                emit error(ArchiveFatalError, node.second);</a>
<a name="ln517">                return ArchiveFatalError;</a>
<a name="ln518">            }</a>
<a name="ln519">            if (r &gt; ARCHIVE_FAILED) {</a>
<a name="ln520">                QScopedPointer&lt;QFile&gt; file(new QFile(node.second));</a>
<a name="ln521">                if(!file-&gt;open(QIODevice::ReadOnly)) {</a>
<a name="ln522">                    emit error(DiskOpenError, node.second);</a>
<a name="ln523">                    return DiskOpenError;</a>
<a name="ln524">                }</a>
<a name="ln525">                len = file-&gt;read(buff, sizeof(buff));</a>
<a name="ln526">                while (len &gt; 0) {</a>
<a name="ln527">                    archive_write_data(m_ArchiveWrite.data(), buff, len);</a>
<a name="ln528">                    n_BytesProcessed += len;</a>
<a name="ln529">                    len = file-&gt;read(buff, sizeof(buff));</a>
<a name="ln530"> </a>
<a name="ln531">		    // The original PR author create a timer to emit this </a>
<a name="ln532">		    // signal every 100 ms but I think it's really not </a>
<a name="ln533">		    // needed.</a>
<a name="ln534">		    // I think his program lagged because we fail to call</a>
<a name="ln535">		    // processEvents in this loop. So if the file is large</a>
<a name="ln536">		    // enough it can easily block the main thread.</a>
<a name="ln537">                    emit progress(QString(node.second),</a>
<a name="ln538">                                  (n_TotalEntries - m_ConfirmedFiles-&gt;size()),</a>
<a name="ln539">                                   n_TotalEntries, n_BytesProcessed, n_BytesTotal);</a>
<a name="ln540">		    </a>
<a name="ln541">		    QCoreApplication::processEvents();</a>
<a name="ln542">		}</a>
<a name="ln543">                file-&gt;close();</a>
<a name="ln544">            }</a>
<a name="ln545"> </a>
<a name="ln546">	    QCoreApplication::processEvents();</a>
<a name="ln547">        }</a>
<a name="ln548"> </a>
<a name="ln549">        emit progress(QString(node.second),</a>
<a name="ln550">                      (n_TotalEntries - m_ConfirmedFiles-&gt;size()),</a>
<a name="ln551">                      n_TotalEntries, n_BytesProcessed, n_BytesTotal);</a>
<a name="ln552"> </a>
<a name="ln553"> </a>
<a name="ln554">        QCoreApplication::processEvents();</a>
<a name="ln555">        if(b_PauseRequested) {</a>
<a name="ln556">            b_PauseRequested = false;</a>
<a name="ln557">            return OperationPaused;</a>
<a name="ln558">        }</a>
<a name="ln559"> </a>
<a name="ln560">        if(b_CancelRequested) {</a>
<a name="ln561">            b_CancelRequested = false;</a>
<a name="ln562">            m_ConfirmedFiles-&gt;clear();</a>
<a name="ln563">            m_ArchiveWrite.clear();</a>
<a name="ln564">            return OperationCanceled;</a>
<a name="ln565">        }</a>
<a name="ln566">    }</a>
<a name="ln567">    m_ArchiveWrite.clear();</a>
<a name="ln568">    return NoError;</a>
<a name="ln569">}</a>

</code></pre>
<div class="balloon" rel="190"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'b_Started' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
