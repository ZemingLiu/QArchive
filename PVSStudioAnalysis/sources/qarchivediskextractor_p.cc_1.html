
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>qarchivediskextractor_p.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &lt;QCoreApplication&gt;</a>
<a name="ln2">#include &lt;QDateTime&gt;</a>
<a name="ln3">#include &lt;QFileInfo&gt;</a>
<a name="ln4"> </a>
<a name="ln5">#include &lt;qarchivediskextractor_p.hpp&gt;</a>
<a name="ln6">#include &lt;qarchive_enums.hpp&gt;</a>
<a name="ln7"> </a>
<a name="ln8">extern &quot;C&quot; {</a>
<a name="ln9">#include &lt;archive.h&gt;</a>
<a name="ln10">#include &lt;archive_entry.h&gt;</a>
<a name="ln11">#include &lt;fcntl.h&gt;</a>
<a name="ln12">#include &lt;stdio.h&gt;</a>
<a name="ln13">#include &lt;stdlib.h&gt;</a>
<a name="ln14">#include &lt;string.h&gt;</a>
<a name="ln15">#include &lt;sys/types.h&gt;</a>
<a name="ln16">#include &lt;sys/stat.h&gt;</a>
<a name="ln17">}</a>
<a name="ln18"> </a>
<a name="ln19">#if defined(__APPLE__)</a>
<a name="ln20">#define st_atim st_atimespec.tv_sec</a>
<a name="ln21">#define st_ctim st_ctimespec.tv_sec</a>
<a name="ln22">#define st_mtim st_mtimespec.tv_sec</a>
<a name="ln23">#elif defined(_WIN32) &amp;&amp; !defined(__CYGWIN__)</a>
<a name="ln24">#define st_atim st_atime</a>
<a name="ln25">#define st_ctim st_ctime</a>
<a name="ln26">#define st_mtim st_mtime</a>
<a name="ln27">#else</a>
<a name="ln28">#define st_atim st_atim.tv_sec</a>
<a name="ln29">#define st_ctim st_ctim.tv_sec</a>
<a name="ln30">#define st_mtim st_mtim.tv_sec</a>
<a name="ln31">#endif</a>
<a name="ln32"> </a>
<a name="ln33">// Helpful macros to check if an archive error is caused due to</a>
<a name="ln34">// faulty passwords.</a>
<a name="ln35">// Expects a pointer to a struct archive , returns 1 if password</a>
<a name="ln36">// is needed or incorrect.</a>
<a name="ln37">#define PASSWORD_NEEDED(a) !qstrcmp(archive_error_string(a) ,&quot;Passphrase required for this entry&quot;)</a>
<a name="ln38">#define PASSWORD_INCORRECT(a) !qstrcmp(archive_error_string(a) , &quot;Incorrect passphrase&quot;)</a>
<a name="ln39"> </a>
<a name="ln40">using namespace QArchive;</a>
<a name="ln41"> </a>
<a name="ln42">// DiskExtractorPrivate constructor constructs the object which is the private class</a>
<a name="ln43">// implementation to the DiskExtractor.</a>
<a name="ln44">// This class is responsible for extraction and information retrival of the data</a>
<a name="ln45">// inside an archive.</a>
<a name="ln46">// This class only extracts the data to the disk and hence the name DiskExtractor.</a>
<a name="ln47">// This class will not be able to extract or work in-memory.</a>
<a name="ln48">DiskExtractorPrivate::DiskExtractorPrivate()</a>
<a name="ln49">    : QObject(),</a>
<a name="ln50">      n_Flags(ARCHIVE_EXTRACT_TIME | ARCHIVE_EXTRACT_PERM | ARCHIVE_EXTRACT_SECURE_NODOTDOT) {</a>
<a name="ln51">    m_Info.reset(new QJsonObject);</a>
<a name="ln52">    m_ExtractFilters.reset(new QStringList);</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55">DiskExtractorPrivate::~DiskExtractorPrivate() {</a>
<a name="ln56">	clear();</a>
<a name="ln57">}</a>
<a name="ln58"> </a>
<a name="ln59"> </a>
<a name="ln60">// Sets the given pointer to QIODevice as the Archive file itself.</a>
<a name="ln61">void DiskExtractorPrivate::setArchive(QIODevice *archive) {</a>
<a name="ln62">    if(b_Started || b_Paused) {</a>
<a name="ln63">        return;</a>
<a name="ln64">    }</a>
<a name="ln65">    clear();</a>
<a name="ln66">    m_Archive = archive;</a>
<a name="ln67">    return;</a>
<a name="ln68">}</a>
<a name="ln69"> </a>
<a name="ln70">// Sets the archive path as the given QString which will be later</a>
<a name="ln71">// opened to be used as the Archive file.</a>
<a name="ln72">void DiskExtractorPrivate::setArchive(const QString &amp;archivePath) {</a>
<a name="ln73">    if(b_Started || b_Paused || archivePath.isEmpty()) {</a>
<a name="ln74">        return;</a>
<a name="ln75">    }</a>
<a name="ln76">    clear();</a>
<a name="ln77">    m_ArchivePath = archivePath;</a>
<a name="ln78">    return;</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">// Blocksize to be used when extracting the given archive.</a>
<a name="ln82">void DiskExtractorPrivate::setBlockSize(int n) {</a>
<a name="ln83">    if(b_Started || b_Paused) {</a>
<a name="ln84">        return;</a>
<a name="ln85">    }</a>
<a name="ln86">    n_BlockSize = n;</a>
<a name="ln87">    return;</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">// Sets the directory where the extraction data to be extracted.</a>
<a name="ln91">void DiskExtractorPrivate::setOutputDirectory(const QString &amp;destination) {</a>
<a name="ln92">    if(b_Started || b_Paused || destination.isEmpty()) {</a>
<a name="ln93">        return;</a>
<a name="ln94">    }</a>
<a name="ln95">    m_OutputDirectory = destination + &quot;/&quot;;</a>
<a name="ln96">    return;</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">// Enables/Disables the progress of the extraction with respect to the</a>
<a name="ln100">// given bool. </a>
<a name="ln101">void DiskExtractorPrivate::setCalculateProgress(bool c) {</a>
<a name="ln102">    b_NoProgress = !c;</a>
<a name="ln103">    return;</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">// Sets the password for the archive when extracting the data.</a>
<a name="ln107">// This method should be accessible even if the extractor is started</a>
<a name="ln108">// since the user may set password anytime. </a>
<a name="ln109">void DiskExtractorPrivate::setPassword(const QString &amp;passwd) {</a>
<a name="ln110">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln111">    if(passwd.isEmpty()) {</a>
<a name="ln112">        return;</a>
<a name="ln113">    }</a>
<a name="ln114">    m_Password = passwd;</a>
<a name="ln115">#else</a>
<a name="ln116">    (void)passwd;</a>
<a name="ln117">#endif</a>
<a name="ln118">    return;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">// Adds extract filters , if set , only the files in the filter</a>
<a name="ln122">// will be extracted , the filter has to correspond to the exact</a>
<a name="ln123">// path given in the archive.</a>
<a name="ln124">void DiskExtractorPrivate::addFilter(const QString &amp;filter) {</a>
<a name="ln125">    if(b_Started || b_Paused || filter.isEmpty()) {</a>
<a name="ln126">        return;</a>
<a name="ln127">    }</a>
<a name="ln128">    *(m_ExtractFilters.data()) &lt;&lt; filter;</a>
<a name="ln129">    return;</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132">// Overload of addFilter to accept list of QStrings.</a>
<a name="ln133">void DiskExtractorPrivate::addFilter(const QStringList &amp;filters) {</a>
<a name="ln134">    if(b_Started || b_Paused || filters.isEmpty()) {</a>
<a name="ln135">        return;</a>
<a name="ln136">    }</a>
<a name="ln137">    *(m_ExtractFilters.data()) &lt;&lt; filters;</a>
<a name="ln138">    return;</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141">// Clears all internal data and sets it back to default.</a>
<a name="ln142">void DiskExtractorPrivate::clear() {</a>
<a name="ln143">    if(b_Started) {</a>
<a name="ln144">        return;</a>
<a name="ln145">    }</a>
<a name="ln146">    n_BlockSize = 10240;</a>
<a name="ln147">    n_PasswordTriedCountGetInfo = n_PasswordTriedCountExtract = 0;</a>
<a name="ln148">    n_TotalEntries = -1;</a>
<a name="ln149">    b_PauseRequested = b_CancelRequested = b_Paused = b_Started = b_Finished = b_ArchiveOpened = false;</a>
<a name="ln150"> </a>
<a name="ln151">    // TODO: do we need to reset n_BytesTotal here?</a>
<a name="ln152">    n_BytesProcessed = 0;</a>
<a name="ln153">    n_BytesTotal = 0;</a>
<a name="ln154"> </a>
<a name="ln155">    m_ArchivePath.clear();</a>
<a name="ln156">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln157">    m_Password.clear();</a>
<a name="ln158">#endif</a>
<a name="ln159">    m_OutputDirectory.clear();</a>
<a name="ln160">    m_ArchiveRead.clear();</a>
<a name="ln161">    m_ArchiveWrite.clear();</a>
<a name="ln162">    m_Info.reset(new QJsonObject);</a>
<a name="ln163">    m_ExtractFilters-&gt;clear();</a>
<a name="ln164"> </a>
<a name="ln165">    if(b_QIODeviceOwned){</a>
<a name="ln166">	    m_Archive-&gt;close();</a>
<a name="ln167">	    m_Archive-&gt;deleteLater();</a>
<a name="ln168">    }else{</a>
<a name="ln169">    	m_Archive = nullptr;</a>
<a name="ln170">    }</a>
<a name="ln171">    b_QIODeviceOwned = false;</a>
<a name="ln172">    return;</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">// Returns the information of the archive through info signal.</a>
<a name="ln176">void DiskExtractorPrivate::getInfo() {</a>
<a name="ln177">    if(!m_Info-&gt;isEmpty()) {</a>
<a name="ln178">        emit info(*(m_Info.data()));</a>
<a name="ln179">        return;</a>
<a name="ln180">    }</a>
<a name="ln181">    short errorCode = NoError;</a>
<a name="ln182"> </a>
<a name="ln183">    // Open the Archive.</a>
<a name="ln184">    if((errorCode = openArchive()) != NoError) {</a>
<a name="ln185">        emit error(errorCode);</a>
<a name="ln186">        return;</a>
<a name="ln187">    }</a>
<a name="ln188"> </a>
<a name="ln189">    errorCode = processArchiveInformation();</a>
<a name="ln190">    if(!errorCode) {</a>
<a name="ln191">        emit info(*(m_Info.data()));</a>
<a name="ln192">    }</a>
<a name="ln193">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln194">    else if(errorCode == ArchivePasswordIncorrect || errorCode == ArchivePasswordNeeded) {</a>
<a name="ln195">        emit getInfoRequirePassword(n_PasswordTriedCountGetInfo);</a>
<a name="ln196">        ++n_PasswordTriedCountGetInfo;</a>
<a name="ln197">    }</a>
<a name="ln198">#endif</a>
<a name="ln199">    else {</a>
<a name="ln200">        emit error(errorCode);</a>
<a name="ln201">    }</a>
<a name="ln202">    return;</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">void DiskExtractorPrivate::start() {</a>
<a name="ln206">    if(b_Started || b_Paused) {</a>
<a name="ln207">        return;</a>
<a name="ln208">    }</a>
<a name="ln209">    short errorCode = NoError;</a>
<a name="ln210"> </a>
<a name="ln211">    // Open the Archive.</a>
<a name="ln212">    if((errorCode = openArchive()) != NoError) {</a>
<a name="ln213">        emit error(errorCode);</a>
<a name="ln214">        return;</a>
<a name="ln215">    }</a>
<a name="ln216"> </a>
<a name="ln217">    // Check and Set Output Directory.</a>
<a name="ln218">    if(!m_OutputDirectory.isEmpty()) {</a>
<a name="ln219">        if((errorCode = checkOutputDirectory()) != NoError) {</a>
<a name="ln220">            emit error(errorCode );</a>
<a name="ln221">            return;</a>
<a name="ln222">        }</a>
<a name="ln223">    }</a>
<a name="ln224"> </a>
<a name="ln225"> </a>
<a name="ln226">    // All Okay then start the extraction.</a>
<a name="ln227">    b_Started = true;</a>
<a name="ln228">    emit started();</a>
<a name="ln229"> </a>
<a name="ln230">    // Get basic information about the archive if the user wants progress on the</a>
<a name="ln231">    // extraction. </a>
<a name="ln232">    if(n_TotalEntries == -1 &amp;&amp; !b_NoProgress) {</a>
<a name="ln233">        errorCode = getTotalEntriesCount();</a>
<a name="ln234">        if(n_TotalEntries == -1) {</a>
<a name="ln235">            // If the total entries is unchanged then there must be an</a>
<a name="ln236">            // error.</a>
<a name="ln237">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln238">            b_Started = false;</a>
<a name="ln239">            if(errorCode == ArchivePasswordIncorrect || errorCode == ArchivePasswordNeeded) {</a>
<a name="ln240">                emit extractionRequirePassword(n_PasswordTriedCountExtract);</a>
<a name="ln241">                ++n_PasswordTriedCountExtract;</a>
<a name="ln242">            }</a>
<a name="ln243">#endif</a>
<a name="ln244">            emit error(errorCode );</a>
<a name="ln245">            return;</a>
<a name="ln246">        }</a>
<a name="ln247">    }</a>
<a name="ln248"> </a>
<a name="ln249">    n_BytesProcessed = 0;</a>
<a name="ln250"> </a>
<a name="ln251">    errorCode = extract();</a>
<a name="ln252">    if(errorCode == NoError) {</a>
<a name="ln253">        b_Started = false;</a>
<a name="ln254">        b_Finished = true;</a>
<a name="ln255">        m_Archive-&gt;close();</a>
<a name="ln256">	emit finished();</a>
<a name="ln257">    }</a>
<a name="ln258">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln259">    else if(errorCode == ArchivePasswordIncorrect || errorCode == ArchivePasswordNeeded) {</a>
<a name="ln260">        b_Started = false;</a>
<a name="ln261">        emit extractionRequirePassword(n_PasswordTriedCountExtract);</a>
<a name="ln262">        ++n_PasswordTriedCountExtract;</a>
<a name="ln263">        emit error(errorCode );</a>
<a name="ln264">    }</a>
<a name="ln265">#endif</a>
<a name="ln266">    else if(errorCode == OperationCanceled) {</a>
<a name="ln267">        b_Started = false;</a>
<a name="ln268">        emit canceled();</a>
<a name="ln269">    } else if(errorCode == OperationPaused) {</a>
<a name="ln270">        b_Started = false;</a>
<a name="ln271">        b_Paused = true;</a>
<a name="ln272">        emit paused();</a>
<a name="ln273">    } else {</a>
<a name="ln274">        b_Started = false;</a>
<a name="ln275">        emit error(errorCode );</a>
<a name="ln276">    }</a>
<a name="ln277">    return;</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">// Pauses the extractor.</a>
<a name="ln281">void DiskExtractorPrivate::pause() {</a>
<a name="ln282">    if(b_Started &amp;&amp; !b_Paused) {</a>
<a name="ln283">        b_PauseRequested = true;</a>
<a name="ln284">    }</a>
<a name="ln285">    return;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">// Resumes the extractor.</a>
<a name="ln289">void DiskExtractorPrivate::resume() {</a>
<a name="ln290">    if(!b_Paused) {</a>
<a name="ln291">        return;</a>
<a name="ln292">    }</a>
<a name="ln293">    b_Paused = false;</a>
<a name="ln294">    b_Started = true;</a>
<a name="ln295">    emit resumed();</a>
<a name="ln296"> </a>
<a name="ln297">    short ret = extract();</a>
<a name="ln298">    if(ret == NoError) {</a>
<a name="ln299">        b_Started = false;</a>
<a name="ln300">        b_Finished = true;</a>
<a name="ln301">        m_Archive-&gt;close();</a>
<a name="ln302">        emit finished();</a>
<a name="ln303">    }</a>
<a name="ln304">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln305">    else if(ret == ArchivePasswordIncorrect || ret == ArchivePasswordNeeded) {</a>
<a name="ln306">        b_Started = false;</a>
<a name="ln307">        emit extractionRequirePassword(n_PasswordTriedCountExtract);</a>
<a name="ln308">        ++n_PasswordTriedCountExtract;</a>
<a name="ln309">        emit error(ret );</a>
<a name="ln310">    }</a>
<a name="ln311">#endif</a>
<a name="ln312">    else if(ret == OperationCanceled) {</a>
<a name="ln313">        b_Started = false;</a>
<a name="ln314">        emit canceled();</a>
<a name="ln315">    } else if(ret == OperationPaused) {</a>
<a name="ln316">        b_Started = false;</a>
<a name="ln317">        b_Paused = true;</a>
<a name="ln318">        emit paused();</a>
<a name="ln319">    } else {</a>
<a name="ln320">        b_Started = false;</a>
<a name="ln321">        emit error(ret );</a>
<a name="ln322">    }</a>
<a name="ln323">    return;</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326">// Cancels the extraction.</a>
<a name="ln327">void DiskExtractorPrivate::cancel() {</a>
<a name="ln328">    if(b_Started &amp;&amp; !b_Paused &amp;&amp; !b_Finished) {</a>
<a name="ln329">        b_CancelRequested = true;</a>
<a name="ln330">    }</a>
<a name="ln331">    return;</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334"> </a>
<a name="ln335">short DiskExtractorPrivate::openArchive() {</a>
<a name="ln336">    if(m_ArchivePath.isEmpty() &amp;&amp; !m_Archive) {</a>
<a name="ln337">        return ArchiveNotGiven;</a>
<a name="ln338">    } else if(b_ArchiveOpened) {</a>
<a name="ln339">        return NoError;</a>
<a name="ln340">    }</a>
<a name="ln341">    // Check and Open the given archive.</a>
<a name="ln342">    //</a>
<a name="ln343">    // Note:</a>
<a name="ln344">    // At this point of code either m_ArchivePath or m_Archive has to be</a>
<a name="ln345">    // set or else the function should have exited with an error signal.</a>
<a name="ln346">    if(!m_ArchivePath.isEmpty()) {</a>
<a name="ln347"> </a>
<a name="ln348">        QFileInfo info(m_ArchivePath);</a>
<a name="ln349">        // Check if the file exists.</a>
<a name="ln350">        if(!info.exists()) {</a>
<a name="ln351">            return ArchiveDoesNotExists;</a>
<a name="ln352">        } else if(!info.isFile()) { // Check if its really a file.</a>
<a name="ln353">            return InvalidArchiveFile;</a>
<a name="ln354">        }</a>
<a name="ln355"> </a>
<a name="ln356">        // Check if we have the permission to read it.</a>
<a name="ln357">        auto perm = info.permissions();</a>
<a name="ln358">        if(</a>
<a name="ln359">            !(perm &amp; QFileDevice::ReadUser) &amp;&amp;</a>
<a name="ln360">            !(perm &amp; QFileDevice::ReadGroup) &amp;&amp;</a>
<a name="ln361">            !(perm &amp; QFileDevice::ReadOther)</a>
<a name="ln362">        ) {</a>
<a name="ln363">            return NoPermissionToReadArchive;</a>
<a name="ln364">        }</a>
<a name="ln365"> </a>
<a name="ln366"> </a>
<a name="ln367">        QFile *file;</a>
<a name="ln368">        try {</a>
<a name="ln369">            file = new QFile(this);</a>
<a name="ln370">	} catch ( ... ) {</a>
<a name="ln371">            m_Archive = nullptr; // Just a precaution.</a>
<a name="ln372">            return NotEnoughMemory;</a>
<a name="ln373">        }</a>
<a name="ln374">        file-&gt;setFileName(m_ArchivePath);</a>
<a name="ln375"> </a>
<a name="ln376">        // Finally open the file.</a>
<a name="ln377">        if(!file-&gt;open(QIODevice::ReadOnly)) {</a>
<a name="ln378">            file-&gt;deleteLater();</a>
<a name="ln379">            return CannotOpenArchive;</a>
<a name="ln380">        }</a>
<a name="ln381"> </a>
<a name="ln382">	b_QIODeviceOwned = true;</a>
<a name="ln383">        m_Archive = (QIODevice*)file;</a>
<a name="ln384">    } else {</a>
<a name="ln385"> </a>
<a name="ln386">        if(!m_Archive-&gt;isOpen()) { // Check if it is opened.</a>
<a name="ln387">            return ArchiveIsNotOpened;</a>
<a name="ln388">        } else if(!m_Archive-&gt;isReadable()) { // Check if it is readable. </a>
<a name="ln389">            return ArchiveIsNotReadable;</a>
<a name="ln390">        }</a>
<a name="ln391">    }</a>
<a name="ln392">    b_ArchiveOpened = true;</a>
<a name="ln393">    return NoError;</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">short DiskExtractorPrivate::checkOutputDirectory() {</a>
<a name="ln397">    QFileInfo info(m_OutputDirectory + &quot;/&quot;);</a>
<a name="ln398">    // Check if its a directory and not a file , Also check if it exists. </a>
<a name="ln399">    if(!info.exists() || !info.isDir()) {</a>
<a name="ln400">        return InvalidOutputDirectory;</a>
<a name="ln401">    }</a>
<a name="ln402"> </a>
<a name="ln403">    // Check if we have the permission to read and write.</a>
<a name="ln404">    if(!info.isWritable() || !info.isReadable()) {</a>
<a name="ln405">        return NoPermissionToWrite;</a>
<a name="ln406">    }</a>
<a name="ln407">    m_OutputDirectory = info.absoluteFilePath();</a>
<a name="ln408">    return NoError;</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">short DiskExtractorPrivate::extract() {</a>
<a name="ln412">    if(m_Archive == nullptr) {</a>
<a name="ln413">        return ArchiveNotGiven;</a>
<a name="ln414">    }</a>
<a name="ln415">    int ret = 0;</a>
<a name="ln416">    short err = NoError;</a>
<a name="ln417">    archive_entry *entry = nullptr;</a>
<a name="ln418"> </a>
<a name="ln419">    if(m_ArchiveRead.isNull() &amp;&amp; m_ArchiveWrite.isNull()) {</a>
<a name="ln420">        n_ProcessedEntries = 0;</a>
<a name="ln421"> </a>
<a name="ln422">        m_ArchiveRead = QSharedPointer&lt;struct archive&gt;(archive_read_new(), ArchiveReadDestructor);</a>
<a name="ln423">        m_ArchiveWrite = QSharedPointer&lt;struct archive&gt;(archive_write_disk_new(), ArchiveWriteDestructor);</a>
<a name="ln424">        if(!m_ArchiveRead.data() || !m_ArchiveWrite.data()) {</a>
<a name="ln425">            m_ArchiveRead.clear();</a>
<a name="ln426">            m_ArchiveWrite.clear();</a>
<a name="ln427">            return NotEnoughMemory;</a>
<a name="ln428">        }</a>
<a name="ln429"> </a>
<a name="ln430">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln431">        if(!m_Password.isEmpty()) {</a>
<a name="ln432">            archive_read_add_passphrase(m_ArchiveRead.data(), m_Password.toUtf8().constData());</a>
<a name="ln433">        }</a>
<a name="ln434">#endif</a>
<a name="ln435">        archive_read_support_format_all(m_ArchiveRead.data());</a>
<a name="ln436">        archive_read_support_filter_all(m_ArchiveRead.data());</a>
<a name="ln437"> </a>
<a name="ln438">        if((ret = archiveReadOpenQIODevice(m_ArchiveRead.data(), n_BlockSize, m_Archive))) {</a>
<a name="ln439">            m_ArchiveRead.clear();</a>
<a name="ln440">            m_ArchiveWrite.clear();</a>
<a name="ln441">            return ArchiveReadError;</a>
<a name="ln442">        }</a>
<a name="ln443"> </a>
<a name="ln444">        if((ret = archive_write_disk_set_options(m_ArchiveWrite.data(), n_Flags))) {</a>
<a name="ln445">            m_ArchiveRead.clear();</a>
<a name="ln446">            m_ArchiveWrite.clear();</a>
<a name="ln447">            return ArchiveWriteError;</a>
<a name="ln448">        }</a>
<a name="ln449"> </a>
<a name="ln450">    }</a>
<a name="ln451">    for (;;) {</a>
<a name="ln452">            ret = archive_read_next_header(m_ArchiveRead.data(), &amp;entry);</a>
<a name="ln453">            if (ret == ARCHIVE_EOF) {</a>
<a name="ln454">                break;</a>
<a name="ln455">            }</a>
<a name="ln456">            if (ret != ARCHIVE_OK) {</a>
<a name="ln457">                err = ArchiveCorrupted;</a>
<a name="ln458">                if(PASSWORD_NEEDED(m_ArchiveRead.data())) {</a>
<a name="ln459">                    err = ArchivePasswordNeeded;</a>
<a name="ln460">                } else if(PASSWORD_INCORRECT(m_ArchiveRead.data())) {</a>
<a name="ln461">                    err = ArchivePasswordIncorrect;</a>
<a name="ln462">                }</a>
<a name="ln463">                m_ArchiveRead.clear();</a>
<a name="ln464">                m_ArchiveWrite.clear();</a>
<a name="ln465">                return err;</a>
<a name="ln466">            }</a>
<a name="ln467"> </a>
<a name="ln468">	    err = writeData(entry);</a>
<a name="ln469">	    if(err == OperationPaused){</a>
<a name="ln470">		    return err;</a>
<a name="ln471">	    }else if(err){ // NoError = 0</a>
<a name="ln472">		    m_ArchiveRead.clear();</a>
<a name="ln473">		    m_ArchiveWrite.clear(); </a>
<a name="ln474">		    return err;</a>
<a name="ln475">	    }</a>
<a name="ln476">	    ++n_ProcessedEntries;</a>
<a name="ln477">	</a>
<a name="ln478">	    // Report final progress signal after extracting the file fully.</a>
<a name="ln479">	    if(n_BytesTotal &gt; 0 &amp;&amp; n_TotalEntries &gt; 0){</a>
<a name="ln480">	    		emit progress(QString(archive_entry_pathname(entry)),</a>
<a name="ln481">                              n_ProcessedEntries,</a>
<a name="ln482">                              n_TotalEntries,</a>
<a name="ln483">                              n_BytesProcessed, n_BytesTotal);</a>
<a name="ln484">	     }else{</a>
<a name="ln485">			emit progress(QString(archive_entry_pathname(entry)),</a>
<a name="ln486">			    1,</a>
<a name="ln487">			    1,</a>
<a name="ln488">			    1,</a>
<a name="ln489">			    1);</a>
<a name="ln490"> </a>
<a name="ln491">	     }</a>
<a name="ln492">	     QCoreApplication::processEvents(); // call event loop for the signal to take effect.</a>
<a name="ln493">    }</a>
<a name="ln494"> </a>
<a name="ln495">    /* free memory. */</a>
<a name="ln496">    m_ArchiveRead.clear();</a>
<a name="ln497">    m_ArchiveWrite.clear(); </a>
<a name="ln498">    return NoError;</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">short DiskExtractorPrivate::writeData(struct archive_entry *entry) {</a>
<a name="ln502">    if(m_ArchiveRead.isNull() || m_ArchiveWrite.isNull() || m_Archive == nullptr) {</a>
<a name="ln503">        return ArchiveNotGiven;</a>
<a name="ln504">    }</a>
<a name="ln505"> </a>
<a name="ln506">    if(!m_ExtractFilters-&gt;isEmpty() &amp;&amp;</a>
<a name="ln507">            !m_ExtractFilters-&gt;contains(QString(archive_entry_pathname(entry)))) {</a>
<a name="ln508">        return NoError;</a>
<a name="ln509">    }</a>
<a name="ln510"> </a>
<a name="ln511">    if(!m_OutputDirectory.isEmpty()) {</a>
<a name="ln512">        char *new_entry = concat(m_OutputDirectory.toUtf8().constData(), archive_entry_pathname(entry));</a>
<a name="ln513">        archive_entry_set_pathname(entry, new_entry);</a>
<a name="ln514">        free(new_entry);</a>
<a name="ln515">    }</a>
<a name="ln516"> </a>
<a name="ln517">    int ret = archive_write_header(m_ArchiveWrite.data(), entry);</a>
<a name="ln518">    if (ret == ARCHIVE_OK) {</a>
<a name="ln519">        const void *buff;</a>
<a name="ln520">        size_t size;</a>
<a name="ln521">#if ARCHIVE_VERSION_NUMBER &gt;= 3000000</a>
<a name="ln522">        int64_t offset;</a>
<a name="ln523">#else</a>
<a name="ln524">        off_t offset;</a>
<a name="ln525">#endif</a>
<a name="ln526">        for (;;) {</a>
<a name="ln527">            ret = archive_read_data_block(m_ArchiveRead.data(), &amp;buff, &amp;size, &amp;offset);</a>
<a name="ln528">            if (ret == ARCHIVE_EOF) {</a>
<a name="ln529">                break;</a>
<a name="ln530">            } else if (ret != ARCHIVE_OK) {</a>
<a name="ln531">                short err = ArchiveCorrupted;</a>
<a name="ln532">                if(PASSWORD_NEEDED(m_ArchiveRead.data())) {</a>
<a name="ln533">                    err = ArchivePasswordNeeded;</a>
<a name="ln534">                } else if(PASSWORD_INCORRECT(m_ArchiveRead.data())) {</a>
<a name="ln535">                    err = ArchivePasswordIncorrect;</a>
<a name="ln536">                }</a>
<a name="ln537">                return err;</a>
<a name="ln538">            } else {</a>
<a name="ln539">                ret = archive_write_data_block(m_ArchiveWrite.data(), buff, size, offset);</a>
<a name="ln540">                if (ret != ARCHIVE_OK) {</a>
<a name="ln541">                    return ArchiveWriteError;</a>
<a name="ln542">                }</a>
<a name="ln543">                n_BytesProcessed += size;</a>
<a name="ln544">		if(n_BytesTotal &gt; 0 &amp;&amp; n_TotalEntries &gt; 0){</a>
<a name="ln545">	    		emit progress(QString(archive_entry_pathname(entry)),</a>
<a name="ln546">                              n_ProcessedEntries,</a>
<a name="ln547">                              n_TotalEntries,</a>
<a name="ln548">                              n_BytesProcessed, n_BytesTotal);</a>
<a name="ln549">		}</a>
<a name="ln550"> </a>
<a name="ln551">	    }</a>
<a name="ln552"> </a>
<a name="ln553">	    // Allow the execution of the event loop</a>
<a name="ln554">            QCoreApplication::processEvents();</a>
<a name="ln555"> </a>
<a name="ln556">	    // Check for pause and cancel requests.</a>
<a name="ln557">	    if(b_PauseRequested) {</a>
<a name="ln558">                b_PauseRequested = false;</a>
<a name="ln559">                return OperationPaused;</a>
<a name="ln560">            }else if(b_CancelRequested) {</a>
<a name="ln561">                b_CancelRequested = false;</a>
<a name="ln562">                return OperationCanceled;</a>
<a name="ln563">            }</a>
<a name="ln564"> </a>
<a name="ln565">        }</a>
<a name="ln566">    } else {</a>
<a name="ln567">        return ArchiveHeaderWriteError;</a>
<a name="ln568">    }</a>
<a name="ln569"> </a>
<a name="ln570">    ret = archive_write_finish_entry(m_ArchiveWrite.data());</a>
<a name="ln571">    if (ret == ARCHIVE_FATAL) {</a>
<a name="ln572">        return ArchiveHeaderWriteError;</a>
<a name="ln573">    }</a>
<a name="ln574">    return NoError;</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">short DiskExtractorPrivate::getTotalEntriesCount() {</a>
<a name="ln578">    if(!m_Archive) {</a>
<a name="ln579">        return ArchiveNotGiven;</a>
<a name="ln580">    }</a>
<a name="ln581"> </a>
<a name="ln582">    n_BytesTotal = 0;</a>
<a name="ln583">    int ret = 0;</a>
<a name="ln584">    int count = 0;</a>
<a name="ln585">    archive_entry *entry = nullptr;</a>
<a name="ln586">    struct archive *inArchive = archive_read_new();</a>
<a name="ln587">    if(!inArchive) {</a>
<a name="ln588">        return NotEnoughMemory;</a>
<a name="ln589">    }</a>
<a name="ln590"> </a>
<a name="ln591">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln592">    if(!m_Password.isEmpty()) {</a>
<a name="ln593">        archive_read_add_passphrase(inArchive, m_Password.toUtf8().constData());</a>
<a name="ln594">    }</a>
<a name="ln595">#endif</a>
<a name="ln596"> </a>
<a name="ln597">    archive_read_support_format_all(inArchive);</a>
<a name="ln598">    archive_read_support_filter_all(inArchive);</a>
<a name="ln599">    if((ret = archiveReadOpenQIODevice(inArchive, n_BlockSize, m_Archive))) {</a>
<a name="ln600">        archive_read_close(inArchive);</a>
<a name="ln601">        archive_read_free(inArchive);</a>
<a name="ln602">        return ArchiveReadError;</a>
<a name="ln603">    }</a>
<a name="ln604">    for (;;) {</a>
<a name="ln605">        ret = archive_read_next_header(inArchive, &amp;entry);</a>
<a name="ln606">        if (ret == ARCHIVE_EOF) {</a>
<a name="ln607">            break;</a>
<a name="ln608">        }</a>
<a name="ln609">        if (ret != ARCHIVE_OK) {</a>
<a name="ln610">            short err = ArchiveCorrupted;</a>
<a name="ln611">            if(PASSWORD_NEEDED(inArchive)) {</a>
<a name="ln612">                err = ArchivePasswordNeeded;</a>
<a name="ln613">            } else if(PASSWORD_INCORRECT(inArchive)) {</a>
<a name="ln614">                err = ArchivePasswordIncorrect;</a>
<a name="ln615">            }</a>
<a name="ln616">            archive_read_close(inArchive);</a>
<a name="ln617">            archive_read_free(inArchive);</a>
<a name="ln618">            return err;</a>
<a name="ln619">        }</a>
<a name="ln620">        count += 1;</a>
<a name="ln621">        n_BytesTotal += archive_entry_size(entry);</a>
<a name="ln622">        QCoreApplication::processEvents();</a>
<a name="ln623">    }</a>
<a name="ln624"> </a>
<a name="ln625">    // set total number of entries.</a>
<a name="ln626">    n_TotalEntries = count;</a>
<a name="ln627"> </a>
<a name="ln628">    // free memory.</a>
<a name="ln629">    archive_read_close(inArchive);</a>
<a name="ln630">    archive_read_free(inArchive);</a>
<a name="ln631">    return NoError;</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634">short DiskExtractorPrivate::processArchiveInformation() {</a>
<a name="ln635">    if(m_Archive == nullptr) {</a>
<a name="ln636">        return ArchiveNotGiven;</a>
<a name="ln637">    }</a>
<a name="ln638"> </a>
<a name="ln639">    int ret = 0;</a>
<a name="ln640">    archive_entry *entry = nullptr;</a>
<a name="ln641">    struct archive *inArchive = archive_read_new();</a>
<a name="ln642">    if(!inArchive) {</a>
<a name="ln643">        return NotEnoughMemory;</a>
<a name="ln644">    }</a>
<a name="ln645">#if ARCHIVE_VERSION_NUMBER &gt;= 3003003</a>
<a name="ln646">    if(!m_Password.isEmpty()) {</a>
<a name="ln647">        archive_read_add_passphrase(inArchive, m_Password.toUtf8().constData());</a>
<a name="ln648">    }</a>
<a name="ln649">#endif</a>
<a name="ln650">    archive_read_support_format_all(inArchive);</a>
<a name="ln651">    archive_read_support_filter_all(inArchive);</a>
<a name="ln652"> </a>
<a name="ln653">    if((ret = archiveReadOpenQIODevice(inArchive, n_BlockSize, m_Archive))) {</a>
<a name="ln654">        archive_read_close(inArchive);</a>
<a name="ln655">        archive_read_free(inArchive);</a>
<a name="ln656">        return ArchiveReadError;</a>
<a name="ln657">    }</a>
<a name="ln658">    for (;;) {</a>
<a name="ln659">        ret = archive_read_next_header(inArchive, &amp;entry);</a>
<a name="ln660">        if (ret == ARCHIVE_EOF) {</a>
<a name="ln661">            break;</a>
<a name="ln662">        }</a>
<a name="ln663">        if (ret != ARCHIVE_OK) {</a>
<a name="ln664">            short err = ArchiveCorrupted;</a>
<a name="ln665">            if(PASSWORD_NEEDED(inArchive)) {</a>
<a name="ln666">                err = ArchivePasswordNeeded;</a>
<a name="ln667">            } else if(PASSWORD_INCORRECT(inArchive)) {</a>
<a name="ln668">                err = ArchivePasswordIncorrect;</a>
<a name="ln669">            }</a>
<a name="ln670">            archive_read_close(inArchive);</a>
<a name="ln671">            archive_read_free(inArchive);</a>
<a name="ln672">            return err;</a>
<a name="ln673">        }</a>
<a name="ln674">        QString CurrentFile = QString(archive_entry_pathname(entry));</a>
<a name="ln675">        QJsonObject CurrentEntry;</a>
<a name="ln676">        auto entry_stat = archive_entry_stat(entry);</a>
<a name="ln677">        qint64 size = (qint64)entry_stat-&gt;st_size;</a>
<a name="ln678">        QString sizeUnits = &quot;Bytes&quot;;</a>
<a name="ln679">        if(size == 0) {</a>
<a name="ln680">            sizeUnits = &quot;None&quot;;</a>
<a name="ln681">            size = 0;</a>
<a name="ln682">        } else if(size &lt; 1024) {</a>
<a name="ln683">            sizeUnits = &quot;Bytes&quot;;</a>
<a name="ln684">            size = size;</a>
<a name="ln685">        } else if(size &gt;= 1024 &amp;&amp; size &lt; 1048576) {</a>
<a name="ln686">            sizeUnits = &quot;KiB&quot;;</a>
<a name="ln687">            size /= 1024;</a>
<a name="ln688">        } else if(size &gt;= 1048576 &amp;&amp; size &lt; 1073741824) {</a>
<a name="ln689">            sizeUnits = &quot;MiB&quot;;</a>
<a name="ln690">            size /= 1048576;</a>
<a name="ln691">        } else {</a>
<a name="ln692">            sizeUnits = &quot;GiB&quot;;</a>
<a name="ln693">            size /= 1073741824;</a>
<a name="ln694">        }</a>
<a name="ln695"> </a>
<a name="ln696">        // MSVC (and maybe Windows in general?) workaround</a>
<a name="ln697">#if defined(_WIN32) &amp;&amp; !defined(__CYGWIN__)</a>
<a name="ln698">        qint64 blockSizeInBytes = 512;</a>
<a name="ln699">        qint64 blocks = (qint64) (entry_stat-&gt;st_size / blockSizeInBytes);</a>
<a name="ln700">#else</a>
<a name="ln701">        qint64 blockSizeInBytes = (qint64)entry_stat-&gt;st_blksize;</a>
<a name="ln702">        qint64 blocks = (qint64)entry_stat-&gt;st_blocks;</a>
<a name="ln703">#endif</a>
<a name="ln704">        auto lastAccessT = entry_stat-&gt;st_atim;</a>
<a name="ln705">        auto lastModT = entry_stat-&gt;st_mtim;</a>
<a name="ln706">        auto lastStatusModT = entry_stat-&gt;st_ctim;</a>
<a name="ln707"> </a>
<a name="ln708">        QFileInfo fileInfo(CurrentFile);</a>
<a name="ln709"> </a>
<a name="ln710">        auto ft = archive_entry_filetype(entry);</a>
<a name="ln711">        QString FileType;</a>
<a name="ln712">        switch(ft) {</a>
<a name="ln713">        case AE_IFREG: // Regular file</a>
<a name="ln714">            FileType = &quot;RegularFile&quot;;</a>
<a name="ln715">            break;</a>
<a name="ln716">        case AE_IFLNK: // Link</a>
<a name="ln717">            FileType = &quot;SymbolicLink&quot;;</a>
<a name="ln718">            break;</a>
<a name="ln719">        case AE_IFSOCK: // Socket</a>
<a name="ln720">            FileType = &quot;Socket&quot;;</a>
<a name="ln721">            break;</a>
<a name="ln722">        case AE_IFCHR: // Character Device</a>
<a name="ln723">            FileType = &quot;CharacterDevice&quot;;</a>
<a name="ln724">            break;</a>
<a name="ln725">        case AE_IFBLK: // Block Device</a>
<a name="ln726">            FileType = &quot;BlockDevice&quot;;</a>
<a name="ln727">            break;</a>
<a name="ln728">        case AE_IFDIR: // Directory.</a>
<a name="ln729">            FileType = &quot;Directory&quot;;</a>
<a name="ln730">            break;</a>
<a name="ln731">        case AE_IFIFO: // Named PIPE. (fifo)</a>
<a name="ln732">            FileType = &quot;NamedPipe&quot;;</a>
<a name="ln733">            break;</a>
<a name="ln734">        default:</a>
<a name="ln735">            FileType = &quot;UnknownFile&quot;;</a>
<a name="ln736">            break;</a>
<a name="ln737">        };</a>
<a name="ln738">        // Set the values.</a>
<a name="ln739">        if(FileType != &quot;RegularFile&quot;) {</a>
<a name="ln740">            CurrentEntry.insert(&quot;FileName&quot;, getDirectoryFileName(CurrentFile));</a>
<a name="ln741">        } else {</a>
<a name="ln742">            CurrentEntry.insert(&quot;FileName&quot;, fileInfo.fileName());</a>
<a name="ln743">        }</a>
<a name="ln744"> </a>
<a name="ln745">        CurrentEntry.insert(&quot;FileType&quot;, QJsonValue(FileType));</a>
<a name="ln746">        CurrentEntry.insert(&quot;Size&quot;, QJsonValue(size));</a>
<a name="ln747">        CurrentEntry.insert(&quot;SizeUnit&quot;, sizeUnits);</a>
<a name="ln748">        CurrentEntry.insert(&quot;BlockSize&quot;, QJsonValue(blockSizeInBytes));</a>
<a name="ln749">        CurrentEntry.insert(&quot;BlockSizeUnit&quot;, &quot;Bytes&quot;);</a>
<a name="ln750">        CurrentEntry.insert(&quot;Blocks&quot;, QJsonValue(blocks));</a>
<a name="ln751">        if(lastAccessT) {</a>
<a name="ln752">            CurrentEntry.insert(&quot;LastAccessedTime&quot;,</a>
<a name="ln753">			    QJsonValue(</a>
<a name="ln754">				   (QDateTime::fromTime_t(lastAccessT)).toString(Qt::ISODate)));</a>
<a name="ln755">        } else {</a>
<a name="ln756">            CurrentEntry.insert(&quot;LastAccessedTime&quot;, &quot;Unknown&quot;);</a>
<a name="ln757">        }</a>
<a name="ln758"> </a>
<a name="ln759">        if(lastModT) {</a>
<a name="ln760">            CurrentEntry.insert(&quot;LastModifiedTime&quot;,</a>
<a name="ln761">			    QJsonValue((QDateTime::fromTime_t(lastModT)).toString(Qt::ISODate)));</a>
<a name="ln762">        } else {</a>
<a name="ln763">            CurrentEntry.insert(&quot;LastModifiedTime&quot;, &quot;Unknown&quot;);</a>
<a name="ln764">        }</a>
<a name="ln765"> </a>
<a name="ln766">        if(lastStatusModT) {</a>
<a name="ln767">            CurrentEntry.insert(&quot;LastStatusModifiedTime&quot;,</a>
<a name="ln768">		QJsonValue((QDateTime::fromTime_t(lastStatusModT)).toString(Qt::ISODate)));</a>
<a name="ln769">        } else {</a>
<a name="ln770">            CurrentEntry.insert(&quot;LastStatusModifiedTime&quot;, &quot;Unknown&quot;);</a>
<a name="ln771">        }</a>
<a name="ln772">        m_Info-&gt;insert(CurrentFile, CurrentEntry);</a>
<a name="ln773">        n_BytesTotal += archive_entry_size(entry);</a>
<a name="ln774">	QCoreApplication::processEvents();</a>
<a name="ln775">    }</a>
<a name="ln776"> </a>
<a name="ln777">    // set total number of entries.</a>
<a name="ln778">    n_TotalEntries = m_Info-&gt;size();</a>
<a name="ln779"> </a>
<a name="ln780">    // free memory.</a>
<a name="ln781">    archive_read_close(inArchive);</a>
<a name="ln782">    archive_read_free(inArchive);</a>
<a name="ln783">    return NoError;</a>
<a name="ln784">}</a>

</code></pre>
<div class="balloon" rel="149"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'b_Started' variable was assigned the same value.</p></div>
<div class="balloon" rel="681"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'size' variable was assigned the same value.</p></div>
<div class="balloon" rel="684"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'size' variable is assigned to itself.</p></div>
<div class="balloon" rel="685"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: size >= 1024.</p></div>
<div class="balloon" rel="688"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: size >= 1048576.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
